#pragma config(Sensor, in1,    LockPot,            sensorPotentiometer)
#pragma config(Sensor, in2,    RLin,           sensorLineFollower)
#pragma config(Sensor, in3,    LLin,           sensorLineFollower)
#pragma config(Sensor, in4,    TLin,           sensorLineFollower)
#pragma config(Sensor, in5,    BLin,           sensorLineFollower)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  LeftBaseEnc,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBaseEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  BtnMogo,        sensorTouch)
#pragma config(Motor,  port1,           LockMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port3,           RFBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RBBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           lock,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           conveyor,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           LFBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LBBase,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int lineThresh = 1000;
volatile bool isAligned = false;

float TruSpeed(float value) {//for all other polynomials; visit: goo.gl/mhvbx4
	return((value*value*value) / (127*127));
}

void fwds(int power) {
	motor[RFBase] = -power;
	motor[RBBase] = -power;
	motor[LFBase] = power;
	motor[LBBase] = power;
}
/*
void driveFor(float goal) {//drives for certain inches
	SensorValue[LeftBaseEnc] = 0;
	SensorValue[RightBaseEnc] = 0;
	goal *= 2;//doubles "goal" not tuned very well as of rn
	const int thresh = 5;//10 ticks
	const int initDir = mRot;
	//ClearTimer(T1);
	const float dP = 20;//multiplier for velocity controller
	float vel = mainVelocity;
	while (abs(goal * circum - encoderAvg*0.25) > thresh) {
		fwds(limitDownTo(15, dP * ((goal*circum - encoderAvg*0.25 - 0.1*vel))), initDir);
	}
	fwds(0, initDir);
	return;
}
*/
void rot(int power) {
	//negative: CW
	//positive: CCW
	motor[RFBase] = power;
	motor[RBBase] = power;
	motor[LFBase] = power;
	motor[LBBase] = power;
}

void swingL(int power) {
	motor[LFBase] = power;
	motor[LBBase] = power;
}

void swingR(int power) {
	motor[RFBase] = power;
	motor[RBBase] = power;
}

void vroomvroom(){

	if (abs(vexRT[Ch3])>10) {
		int speed = TruSpeed(vexRT[Ch3]);
		motor[LFBase] = speed;
		motor[LBBase] = speed;
	}
	else {
		motor[LFBase] = 0;
		motor[LBBase] = 0;
	}

	if (abs(vexRT[Ch2])>10) {
		int speed = TruSpeed(vexRT[Ch2]);
		motor[RFBase] = -speed;
		motor[RBBase] = -speed;
	}
	else {
		motor[RFBase] = 0;
		motor[RBBase] = 0;
	}

	if (vexRT[Btn5U]) motor[lock] = 127;
	else if (vexRT[Btn5D])motor[lock] = -127;
	else motor[lock] = 0;

	if (vexRT[Btn6U]){
		motor[conveyor] = 127;
	}
	else if (vexRT[Btn6D]){
		motor[conveyor] = -127;
	}
	else {
		motor[conveyor] = 0;
	}
}

void perpendicular(int dir, bool isLeftFirst){ //specify whether back align (-1) or fwd align (1)
	int power = 25;
	if(isLeftFirst){
		//if left crosses line first, swing right
		while(SensorValue[RLin] > lineThresh){
			swingR(dir * power);
		}
	}
	else {
		//if right crosses line first, swing left
		while(SensorValue[LLin] > lineThresh){
			swingL(dir * power);
		}
	}
	/*
	if((SensorValue[LLin] + SensorValue[RLin]) > 500){ //check if skid puts the robot off alignment
		power -= 10; //decrease power each time
		align(dir, !isLeftFirst); //recursive function to make sure it aligns
	}*/

	fwds(0);
	isAligned = true;
}

void alignPerp(){
	isAligned = (SensorValue[RLin] + SensorValue[LLin] < lineThresh);
	while(!isAligned){
		if(SensorValue[LLin] < lineThresh){
			motor[LFBase] = 0;
			motor[LBBase] = 0;
			motor[RFBase] = 0;
			motor[RBBase] = 0;
			//isAligned = true;

			perpendicular(-1, true); //left side approach
		}
		else if (SensorValue[RLin] < lineThresh){
			motor[LFBase] = 0;
			motor[LBBase] = 0;
			motor[RFBase] = 0;
			motor[RBBase] = 0;
			//isAligned = true;
			perpendicular(-1, false); //right side approach
		}
		else {
			fwds(-25); //speed where robot will stop on line
		}
	}
}



task main()
{
	SensorFullCount[Gyro] = 36000;

	for(;;){
		vroomvroom();
		if(vexRT[Btn7U]){ //left swing fwd
			swingL(100);
			delay(100);
			fwds(0);
		}
		if(vexRT[Btn7L]){ //left swing bck
			swingL(-100);
			delay(100);
			fwds(0);
		}
		if(vexRT[Btn7R]){ //right swing fwd
			swingR(100);
			delay(100);
			fwds(0);
		}
		if(vexRT[Btn7D]){ //right swing bck
			swingR(-100);
			delay(100);
			fwds(0);
		}
		if(vexRT[Btn8R]){
			alignPerp();
		}
		delay(10);
	}
}
