#pragma config(Sensor, in1,    RLin,           sensorLineFollower)
#pragma config(Sensor, in2,    LLin,           sensorLineFollower)
#pragma config(Sensor, in3,    LockPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    FourBarPot,     sensorPotentiometer)
#pragma config(Sensor, in5,    BATERY_2_PORT,  sensorAnalog)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  LeftBaseEnc,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBaseEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  MogoFront,      sensorTouch)
#pragma config(Sensor, dgtl6,  MogoEnd,        sensorTouch)
#pragma config(Sensor, dgtl8,  sonar,          sensorSONAR_cm)
#pragma config(Motor,  port2,           ClawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RFourBarMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           ConveyorMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LFourBarMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LockMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!5
#include "Vex_Competition_Includes.c"
#include "randomstuff.h"
#include "dataStructures.h"
#include "mech.h"
#include "rotate.h"
#include "physics.h"
#include "lift.h"
#include "init.h"
#include "other.h"
void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
	SensorType[Gyro] = sensorGyro;
	wait1Msec(1220);
	//Adjust SensorScale to correct the scaling for your gyro
	scaleGyros();
	while (bIfiRobotDisabled) {//in preauton
	//	autonSelect(nLCDButtons);
	}
}
void initializeOpControl(const bool driver) {
	clearLCDLine(0);
	clearLCDLine(1);
	if (driver) resetGyros();//wastes time on auton
		mainVelocity = 0.0;
	//--------&reference-------TYPE-----------sensor-----------motor1---------motor2------------motor3-----(min, max)
	initMech( &conveyer,	 CONVEYER,    0,		ConveyorMotor,		0 	);//CONVEYOR
	initMech( &baseLeft,	 DRIVE,	      	LeftBaseEnc,		LBaseFront,		  LBaseBack);//LEFT BASE
	initMech( &baseRight,	 DRIVE,		  	RightBaseEnc,		RBaseFront,		  RBaseBack);//RIGHT BASE
	initLift( &lock,								LockPot,			LockMotor, 			0,						1000, 2000);//(min) && (max)
	initLift( &fourBar,							FourBarPot,		RFourBarMotor,		LFourBarMotor,		1300,	3500, 10);
	//--------&reference-------Sensor------thresh---kP---kI---kD---reversed---isRunning
	initPID ( &fourBar.PID, fourBar.m.sensor, 50, 0.05,  0.0, 0.05, 	true, 		true);
	initPID ( &lock.PID,		lock.m.sensor, 		30, 0.5, 	 0.0, 0.0, 		true, 		true);
	initPID ( &gyroBase, 		Gyro, 						1,  1, 0.0, 0, 		true, 		false);//kP = .35, kD = 0.6
	pastRot = mRot;
}
task intakeToLock(){
	while(SensorValue[MogoEnd] == 0){
		mechMove(&conveyer.m, INTAKE);
	}
	delay(200);
	lock.goal = lock.min;//turns on PID
	lock.PID.isRunning = true;
	playSound(soundBeepBeep);
	LOCK;//brings up levitator
	lock.goal = SensorValue[lock.m.sensor];//turns on PID
	lock.PID.isRunning = true;
	//mechMove(&conveyer.m, 0);
	return;
}
task intakeSecond(){
	//pick up second mogo
	while(SensorValue[MogoFront] == 0){
		mechMove(&conveyer.m, INTAKE);
	}
	delay(100);
	clawControl(OPEN);
	while(SensorValue[MogoFront] == 1){
		mechMove(&conveyer.m, INTAKE);//slower speed once intook (button pressed)
	}
	//clawControl(OPEN);clawControl(OPEN);clawControl(OPEN);clawControl(OPEN);//spams claw open just to make sure
	playSound(soundBlip);
	mechMove(&conveyer.m, 0);
	return;
}
task dropCone(){
	while(SensorValue[MogoFront] == 0)//wait until button pressed
		continue;
	playSound(soundUpwardTones);
	clawControl(OPEN);//spams claw open to ensure
	delay(1000);
	fourBar.goal = fourBar.min + 400;//then brings out the fourbar a bit
	fourBar.PID.isRunning = true;
	return;
}
task conveyerMove(){
	stopTask(MechControlTask);
	for(;;){
		if(autonRunning) mechMove(&conveyer.m, conveyer.speed);//allows multitasking
		delay(50);
	}
}
void twentyScore(){
	lock.goal = lock.max;//unlocks mogo
	fwds(-127, mRot);
	delay(600);
	conveyer.speed = INTAKE;
	fwds(-127, mRot);
	delay(400);
	fwds(0, mRot);
	delay(400);
}
void crossField(const int initialDistance, const int secondaryDistance, bool withCone) {
	const int initialMRot = SensorValue[Gyro]*GyroK;
	lock.goal = lock.max;
	UNLOCK;
	conveyer.speed = INTAKE;
	fourBar.goal = RELEASE + 500;
	fourBar.PID.isRunning = true;
	startTask(intakeToLock);//picks up first mogo
	driveFor(initialDistance);
	fourBar.goal = RELEASE;
	fwds(70, mRot);//slows down drive
	clearTimer[T1];
		while(abs(SensorValue[Gyro]*GyroK - initialMRot) > 1 && time1[T1] < 500)	rot(-10*(SensorValue[Gyro]*GyroK - initialMRot));//corrects angle if off course
	delay(500);//waits for mogo pickup
	startTask(intakeSecond);
	if (withCone) startTask(dropCone);
	driveFor(secondaryDistance);
	fourBar.goal = avg(fourBar.min, fourBar.max);
	conveyer.speed = INTAKE / 6;
	delay(300);
	lock.goal = lock.min;
	settle();
}
volatile int clawSpeed = 0;
task clawHold(){
	for(;;){
		motor[ClawMotor] = clawSpeed;
		delay(10);
	}
}
void progSkillsTest(){
	startTask(conveyerMove);
	startTask(killswitch);
	startTask(liftPID);
	autonRunning = true;
	//resetGyros();//NEVER USE (for some reason?)
	///////////////////////////////STAGE 1/////////////////////////////
	crossField(80, 70, true);
	conveyer.speed = 0;
	delay(100);
	rotAcc(87.5, 1000);
	fourBar.goal = RELEASE;
	delay(300);
	driveFor(-12.5);//-12);
	settle();
	delay(100);
	rotAcc(85);
	delay(50);
	SensorValue[Gyro] = 0;
	fourBar.goal = avg(fourBar.min, fourBar.max);
	lock.PID.isRunning = false;
	conveyer.speed = 0;
	twentyScore();//SCORES FIRST TWO IN ZONE
	settle();
	delay(300);
	driveFor(30);
	fourBar.goal = RELEASE;//brings to rear again
	//'s' motion
	alignToLine(1);//aligns to tape line
	conveyer.speed = INTAKE/8;//turn off conveyer
	settle();
	delay(200);
	rotAcc(90);
	settle();
	alignSonar(42);
	settle();
	delay(400);
	rotAcc(-88);
	settle();
	///////////////////////////////STAGE 2/////////////////////////////
	delay(300);
	crossField(80, 62, false);
	fourBar.goal = RELEASE;
	conveyer.speed = 0;
	rotAcc(90);
	driveFor(-11);
	settle();
	rotAcc(85);
	lock.PID.isRunning = false;
	twentyScore();
	driveFor(26);
	///////////////////////////////STAGE 3/////////////////////////////
	alignToLine(1);
	rotAcc(90);
	alignSonar(27);
	settle();
	delay(200);
	rotAcc(-46,1000);
	const int initialMRot = SensorValue[Gyro]*GyroK;
	settle();
	delay(50);
	startTask(intakeToLock);
	delay(200);
	driveFor(80);
	clearTimer(T1);
	while(abs(SensorValue[Gyro]*GyroK - initialMRot) > 1 && time1[T1] < 500)	rot(-10*(SensorValue[Gyro]*GyroK - initialMRot));
	settle();
	delay(300);
	driveFor(-7);
	fourBar.goal = PICKUP;
	clawSpeed = -127;
	startTask(clawHold);
	delay(400);
	rotAcc(-18.5, 800);
	settle();
	delay(100);
	driveFor(9);
	clawSpeed = 100;//pickup cone
	delay(400);
	stopTask(clawHold);
	delay(400);//settling
	DownUntil(&fourBar, fourBar.min, 80);
	delay(100);
	settle();
	delay(300);
	rotAcc(-11, 300);
	startTask(dropCone);
	startTask(intakeSecond);
	driveFor(34);
	delay(600);
	fourBar.goal = PICKUP;
	conveyer.speed = 0;
	delay(500);
	rotAcc(-50, 1000);
	//DONE
	autonRunning = false;
	startTask(MechControlTask);
	return;
}
task autonomous() {
	autonRunning = true;
	initializeOpControl(false);//auton init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(conveyerMove);//allows for multitasking
	//startTask(antiStall);
	startTask(clawTask);
	progSkillsTest();
	return;
}
task usercontrol() {//initializes everything
	initializeOpControl(true);//driver init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(antiStall);
	//startTask(killswitch);
	startTask(displayLCD);
	startTask(clawTask);
	SensorValue[Gyro] = 0;//resets gyros
	SensorScale[Gyro] = 260;
	autonRunning = false;
	fourBar.goal = RELEASE;
	if(nImmediateBatteryLevel < 8300) playSound(soundException);
	else playSound(soundUpwardTones);
	for (;;) {
		//debug controls
		if(L7) rotAcc(45);
		if(R7) rotAcc(-45);//clawControl(OPEN);
		if(U7) progSkillsTest();
		if(D7) turn(45, 2);
		LiftLift(&fourBar, D5, U5, D5_2, U5_2, 5000, true);
		LiftLift(&lock, U8, D8, U8_2, D8_2, 100, true);
		delay(30);//~60hz
	}
}//function for operator control
