#pragma config(Sensor, in1,    RLin,           sensorLineFollower)
#pragma config(Sensor, in2,    LLin,           sensorLineFollower)
#pragma config(Sensor, in3,    MLin,           sensorLineFollower)
#pragma config(Sensor, in5,    BATERY_2_PORT,  sensorAnalog)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  LeftBaseEnc,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBaseEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  MogoFront,      sensorTouch)
#pragma config(Sensor, dgtl6,  MogoEnd,        sensorTouch)
#pragma config(Sensor, dgtl8,  sonar,          sensorSONAR_cm)
#pragma config(Motor,  port2,           RConveyorMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LConveyorMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LockMotor,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!5
#include "Vex_Competition_Includes.c"

#include "include/skills/randomstuff.h"
#include "include/skills/dataStructures.h"
#include "include/skills/mech.h"
#include "include/skills/PID.h"
#include "include/skills/lift.h"
#include "include/skills/other.h"
#include "include/skills/drive.h"
#include "include/skills/rotate.h"
#include "include/skills/physics.h"
#include "include/skills/init.h"

int startDir = 0;

void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
	SensorType[Gyro] = sensorGyro;
	wait1Msec(1220);
	//Adjust SensorScale to correct the scaling for your gyro
	scaleGyros();
	while (bIfiRobotDisabled) {//in preauton
		startTask(displayLCD);
	}
}
void initializeOpControl(const bool driver) {
	clearLCDLine(0);
	clearLCDLine(1);
	if (driver) resetGyros();//wastes time on auton
		mainVelocity = 0.0;
	//--------&reference-------TYPE-----------sensor-----------motor1---------motor2------------motor3-----(min, max)
	initMech( &conveyer,	 CONVEYER,    0,		RConveyorMotor,		LConveyorMotor 	);//CONVEYOR
	initMech( &baseLeft,	 DRIVE,	      	LeftBaseEnc,		LBaseFront,		  LBaseBack);//LEFT BASE
	initMech( &baseRight,	 DRIVE,		  	RightBaseEnc,		RBaseFront,		  RBaseBack);//RIGHT BASE
	//initLift( &lock,								LockPot,			LockMotor, 			0,						1000, 2000);//(min) && (max)
	//initLift( &fourBar,							FourBarPot,		RFourBarMotor,		LFourBarMotor,		1300,	3500, 10);
	//--------&reference-------Sensor------thresh---kP---kI---kD---reversed---isRunning
	initPID ( &fourBar.PID, fourBar.m.sensor, 50, 0.05,  0.0, 0.05, 	true, 		true);
	initPID ( &lock.PID,		lock.m.sensor, 		30, 0.5, 	 0.0, 0.0, 		true, 		true);
	initPID ( &gyroBase, 		Gyro, 						1,  1, 0.0, 0, 		true, 		false);//kP = .35, kD = 0.6
	pastRot = mRot;
}
task intakeMogos(){
	//pick up first mogo
	while(SensorValue[MogoFront] == 0){
		motor[LConveyorMotor] = INTAKE;
		motor[RConveyorMotor] = INTAKE;
	}
	//clawControl(OPEN);
	while(SensorValue[MogoFront] == 1){
		motor[LConveyorMotor] = INTAKE;
		motor[RConveyorMotor] = INTAKE;
	}
	//clawControl(OPEN);clawControl(OPEN);clawControl(OPEN);clawControl(OPEN);//spams claw open just to make sure
	playSound(soundBlip);
	motor[LConveyorMotor] = 0;
	motor[RConveyorMotor] = 0;

	delay(500);

	//pick up second mogo
	while(SensorValue[MLin] > 150){
		motor[LConveyorMotor] = INTAKE;
		motor[RConveyorMotor] = INTAKE;
	}
	while(SensorValue[MogoFront] == 0){
		motor[LConveyorMotor] = INTAKE;
		motor[RConveyorMotor] = INTAKE;
	}
	delay(150);
	playSound(soundBlip);
	motor[LConveyorMotor] = 0;
	motor[RConveyorMotor] = 0;
	return;
}
task intakeMogo(){
	//intake one mogo, all the way at the top

	while(SensorValue[MogoEnd] == 0){
		//keep running conveyer
		//conveyer.speed=INTAKE;
		motor[LConveyorMotor] = INTAKE;
		motor[RConveyorMotor] = INTAKE;
	}
	while(SensorValue[MogoEnd] == 1){
		//keep running conveyer
		//conveyer.speed=INTAKE;
		motor[LConveyorMotor] = INTAKE;
		motor[RConveyorMotor] = INTAKE;
	}
	playSound(soundBlip);
	//conveyer.speed=0;
	motor[LConveyorMotor] = 0;
	motor[RConveyorMotor] = 0;
}
task conveyerMove(){
	stopTask(MechControlTask);
	for(;;){
		if(autonRunning) mechMove(&conveyer.m, conveyer.speed);//allows multitasking
			delay(50);
	}
}
task crossField() {
	//startTask(conveyerMove);
	//startTask(killswitch);
	conveyer.speed = INTAKE;
	startTask(intakeMogos);
	driveFor(110);
	rotEnc(135);
	return;
}
task skillsTest1() {
	startTask(conveyerMove);
	startTask(killswitch);

	//Corner Mogo
	startDir = mRot;
	motor[LConveyorMotor] = INTAKE;
	motor[RConveyorMotor] = INTAKE;
	startTask(intakeMogo);
	driveFor(60);//drive and grab mogo
	if(abs(startDir-mRot)>2)rotTune(startDir-mRot+2);//angular correction
	driveFor(-58);//come back to 10pt pole
	RSwingFor(-40);//align with 10pt
	motor[LConveyorMotor] = INTAKE;
	motor[RConveyorMotor] = INTAKE;
	delay(200);//release mogo in 10pt

	//Cross Field
	startTask(intakeMogos);
	driveFor(110); //drive and intake 2 mogos
	rotEnc(135);

	//End
	startTask(MechControlTask);
}
task skillsTest2(){
	startTask(intakeMogos);
	driveFor(110);
	rotEnc(110);
	driveFor(-20);
	LSwingFor(-35);/*
	fwds(127);//full power drive forward
	delay(700);
	motor[LConveyorMotor] = INTAKE;
	motor[RConveyorMotor] = INTAKE;
	delay(200);
	fwds(-127);*/

	startTask(MechControlTask);
}
task usercontrol() {//initializes everything
	initializeOpControl(true);//driver init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	//startTask(antiStall);
	//startTask(killswitch);
	startTask(displayLCD);
	//startTask(clawTask);
	SensorValue[Gyro] = 0;//resets gyros
	SensorScale[Gyro] = 260;
	autonRunning = false;
	fourBar.goal = RELEASE;
	if(nImmediateBatteryLevel < 8500) playSound(soundException);
	else playSound(soundUpwardTones);
	/*
	//get initial angle
	for(int i=0;i<8;i++){
		startDir+=SensorValue[Gyro]*GyroK;
		delay(5);
	}
	startDir = startDir>>3;
	*/
	for (;;) {
		//debug controls
		if(R7) rotEnc(startDir - mRot);//driveFor(30); //startTask(intakeToLock);//(TUNED)
		if(L7) driveFor(50);//driveFor(-30);
		if(R8) RSwingFor(-45);
		if(L8) RSwingFor(45);
		if(U8) rotEnc(-90);
		if(D8) rotEnc(90);
		if(U7) startTask(skillsTest2);
		//accelerometer driving:
		/*
		float yaxis = 2*vexRT[AccelY];//drive
		float xaxis = 2*vexRT[AccelX];//rotate
		if(abs(yaxis) > abs(xaxis)){
			analogMechControl(&baseRight.m, -yaxis );
			analogMechControl(&baseLeft.m, -yaxis );
		}
		else{
			analogMechControl(&baseRight.m, -xaxis );
			analogMechControl(&baseLeft.m,   xaxis );
		}
		//if(abs(yaxis) > 20) 			fwds(-TruSpeed(yaxis));
		//else if(abs(xaxis) > 20)	rot(-TruSpeed(xaxis));
		*/
		//LiftLift(&fourBar, D5, U5, D5_2, U5_2, 5000, true);
		//LiftLift(&lock, U8, D8, U8_2, D8_2, 100, true);
		delay(30);//~60hz
	}
}//function for operator control
