#pragma config(Sensor, in1,    RLin,           sensorLineFollower)
#pragma config(Sensor, in2,    LLin,           sensorLineFollower)
#pragma config(Sensor, in3,    MLin,           sensorLineFollower)
#pragma config(Sensor, in4,    MFLin,          sensorLineFollower)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  LeftBaseEnc,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBaseEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  MogoFront,      sensorTouch)
#pragma config(Sensor, dgtl6,  MogoEnd,        sensorTouch)
#pragma config(Sensor, dgtl8,  Lsonar,         sensorSONAR_cm)
#pragma config(Sensor, dgtl11, Rsonar,         sensorSONAR_cm)
#pragma config(Motor,  port2,           RConveyor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           elevator,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LConveyor,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)


// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!5
#include "Vex_Competition_Includes.c"
#include "include/skills/randomstuff.h"
#include "include/skills/dataStructures.h"
#include "include/skills/mech.h"
#include "include/skills/PID.h"
#include "include/skills/lift.h"
#include "include/skills/other.h"
#include "include/skills/drive.h"
#include "include/skills/rotate.h"
#include "include/skills/physics.h"
#include "include/skills/init.h"

#define withCorrection true

int startDir = 0;

void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
	SensorType[Gyro] = sensorGyro;
	wait1Msec(1220);
	//Adjust SensorScale to corr	ect the scaling for your gyro
	scaleGyros();
	while (bIfiRobotDisabled) {//in preauton
		startTask(displayLCD);
	}
}
void initializeOpControl(const bool driver) {
	clearLCDLine(0);
	clearLCDLine(1);
	if (driver) resetGyros();//wastes time on auton
	mainVelocity = 0.0;
	resetencoders();
	//--------&reference-------TYPE-----------sensor-----------motor1---------motor2-----//
	initMech( &conveyer,       CONVEY,        0,               LConveyor,     RConveyor);//CONVEYOR
	initMech( &baseLeft,       DRIVE,         LeftBaseEnc,     LBaseFront,    LBaseBack);//LEFT BASE
	initMech( &baseRight,      DRIVE,         RightBaseEnc,    RBaseFront,    RBaseBack);//RIGHT BASE
	//--------&reference-------Sensor------------thresh---kP----kI---kD-----reversed---isRunning
	initPID ( &gyroBase,       Gyro,             1,       1,    0.0, 0,     true,      false);//kP = .35, kD = 0.6
	pastRot = mRot;
}
bool firstCrossing = true;
task intakeMogos(){
	//pick up first mogo
	while(SensorValue[MFLin] > 350){//SensorValue[MogoFront] == 0){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
	if(firstCrossing) delay(450);
	else delay(500);
	//pick up second mogo
	while(SensorValue[MLin] > 350){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	while(SensorValue[MFLin] > 350){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	clearTimer(T4);
	while(time1(T4)<150) {//outtake 20pt mogo
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
	return;
}
task intakeMogo(){
	clearTimer(T1);
	//intake one mogo, all the way at the top
	while(SensorValue[MogoEnd] == 0 && time1[T1] < 5000){
		//keep running conveyer
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	while(SensorValue[MogoEnd] == 1 && time1[T1] < 5000){
		//keep running conveyer
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
	return;
}
void skillsPart1() {
	//corner mogo (loader)
	startDir = mRot;
	motor[LConveyor] = INTAKE;
	motor[RConveyor] = INTAKE;
	startTask(intakeMogo);
	driveFor(60, withCorrection);//drive and grab mogo (with drive correction)
	//	if( abs( startDir - mRot ) > 2) rotTune( startDir - mRot + 2);//angular correction (kinda bad...)
	driveFor(-58, withCorrection);//come back to 10pt pole (With correction)
	RSwingFor(-40);//align with 10pt
	clearTimer(T4);
	while(time1[T4] < 500){//release mogo in 10pt OPTIMIZE
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	delay(200);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
}
void skillsPart2(bool firstCross){

	//Cross Field
	if(firstCross) firstCrossing = true;
	else firstCrossing = false;
	startTask(intakeMogos);
	if(firstCross) driveFor(110); //intake mogos (NO correction)
	else driveFor(108); //intake mogos (NO correction) (less than first time)
		//Double Mogo Score
	rotEnc(125); //OPTIMIZE closer to left side of zone
	driveFor(-17); //drive to center
	LSwingFor(45); //swing to 10pt pole

	clearTimer(T4);
	while(time1(T4)<200) fwds(127);//full power drive forward
	fwds(0);
	delay(200);
	clearTimer(T4);
	while(time1(T4)<1000) fwds(-127);//full power drive forward
		clearTimer(T4);
	while(time1(T4)<400) {//outtake 20pt mogo and drive fwds
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
		fwds(-127);
	}
	fwds(0);
	clearTimer(T4);
	while(time1(T4)<500) {//outtake 20pt mogo
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	clearTimer(T4);
	while(time1(T4)<200) fwds(0);//stop stalling our base
	clearTimer(T4);
	if(firstCross){
		while(time1(T4)<900) {//start driving out of 10pt
			motor[LConveyor] = INTAKE;
			motor[RConveyor] = INTAKE;
			fwds(127);
		}
	}
	else {
		while(time1[T4]<900){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
		fwds(127);
		}
	}
}
task releaseMogoDumb(){
	clearTimer(T3);
	while(time1[T3] < 600){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
	return;
}
void skillsPart3() {

	//Align after double mogo
	alignToLine(1);
	driveFor(7);
	rotEnc(-90);
	delay(200);//settle time

	//Right Mogo
	driveToSonar(RIGHT, 12.5); //drive to wall
	RSwingFor(35); //face mogo
	startDir = mRot;
	//delay(200);
	startTask(intakeMogo);
	driveFor(14); //drive to middle line
	alignToLine(1); //align line
	delay(100);
	driveFor(30); //intake mogo

	//driveFor(47);
	if( abs( startDir - mRot ) > 1.5) rotTune(0.5*(startDir - mRot));//angular correction
	driveFor(-55, withCorrection); //drive back(with correction)
	LSwingFor(47); //align with 10pt
	clearTimer(T4);
	while(time1[T4]<100){ //release mogo in 10pt //UNDO IF NOT WORK
		fwds(-90);//drive back whilst doing this
	}
	clearTimer(T4);
	while(time1[T4]<500){ //release mogo in 10pt //UNDO IF NOT WORK
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
		fwds(-50);//drive back whilst doing this
	}
	fwds(0);
	delay(300);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;

	//Align after right mogo
	alignToLine(1);
	driveFor(7);
	rotEnc(90);
	startTask(releaseMogoDumb);
	//Left Mogo
	driveToSonar(LEFT, 11); //drive to wall
	/*LSwingFor(-35); //face mogo
	delay(200);
	startTask(intakeMogo);
	driveFor(20);
	clearTimer(T4);
	while(time1[T4]<80) { rot(127); }
	rot(0);
	driveFor(27);
	driveFor(-48);*/
	LSwingFor(-37.5); //face mogo
	delay(200);
	startDir = mRot;
	startTask(intakeMogo);

	driveFor(13); //drive to middle line
	alignToLine(1); //align line
	delay(200);
	driveFor(30); //intake mogo
	delay(200);
	if( abs( startDir - mRot ) > 2) rotTune(0.5*(startDir - mRot));//angular correction
	driveFor(-52, withCorrection);//(TRY NOT TO HIT CONES ON WAY BACK)
	RSwingFor(-40); //align with 10pt
	delay(300);
	clearTimer(T4);
	while(time1[T4]<100){
		fwds(-85);//drive back a bit to ensure 10pt
	}
	clearTimer(T4);
	while(time1[T4]<500){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
		fwds(-40);//drive back a bit to ensure 10pt
	}
	fwds(0);
	delay(200);//release mogo in 10pt
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
}
void skillsPart4 () {
	//Align after double mogo
	alignToLine(1);
	driveFor(7);
	rotEnc(-90);
	delay(300);

	//Right Mogo
	driveToSonar(RIGHT, 12); //drive to wall
	RSwingFor(34); //face mogo
	delay(100);
	startDir = mRot;
	startTask(intakeMogo);
	driveFor(15); //intake mogo
	alignToLine(1);
	driveFor(27);
	if( abs(startDir - mRot ) > 3) rotTune((startDir - mRot));//angular correction
	else delay(200);
	driveFor(-50, withCorrection); //drive back(CONT HIT CONES)
	LSwingFor(47); //align with 10pt
	clearTimer(T4);
	while(time1[T4]<600){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
		fwds(-40);
	}
	delay(300);//release mogo in 10pt
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;

	//Park
	LSwingFor(-45);
	driveFor(60, withCorrection);//lol 102 pls
}
void progSkills(){
	//skills order: 1, 2, 3, 2, 4
	skillsPart1();
	skillsPart2(true);
	skillsPart3();
	skillsPart2(false);
	skillsPart4();
	return;
}

task autonomous(){
	initializeOpControl(false);//AUTONOMOUS, NOT DRIVER init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	//startTask(antiStall); no
	//startTask(killswitch);
	startTask(displayLCD);
	//SensorValue[Gyro] = 0;//resets gyros
	//SensorScale[Gyro] = 260;
	autonRunning = true;
	//delay(1000);
	progSkills();

}
task usercontrol() {//initializes everything
	initializeOpControl(true);//driver init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	//startTask(antiStall); no
	startTask(killswitch);
	startTask(displayLCD);
	SensorValue[Gyro] = 0;//resets gyros
	SensorScale[Gyro] = 260;
	autonRunning = false;
	//if(nImmediateBatteryLevel < 8500) playSound(soundException);
	//else playSound(soundUpwardTones);

	for (;;) {
		//debug controls
		//do not use D7 -- killswitch
		if(L7) alignToLine(1);
		if(U7) driveFor(50);
		if(R7) rotEnc(-90, true);
		if(D7) startTask(intakeMogos);
		if(R8) progSkills();
		if(U5) skillsPart1();
		if(D5) skillsPart2(true);
		if(U8) skillsPart3();
		if(D8) skillsPart4();

		//accelerometer driving:
		/*
		float yaxis = 2*vexRT[AccelY];//drive
		float xaxis = 2*vexRT[AccelX];//rotate
		if(abs(yaxis) > abs(xaxis)){
		analogMechControl(&baseRight.m, -yaxis );
		analogMechControl(&baseLeft.m, -yaxis );
		}
		else{
		analogMechControl(&baseRight.m, -xaxis );
		analogMechControl(&baseLeft.m,   xaxis );
		}
		//if(abs(yaxis) > 20) 			fwds(-TruSpeed(yaxis));
		//else if(abs(xaxis) > 20)	rot(-TruSpeed(xaxis));
		*/
		delay(30);//~60hz
	}
}//function for operator control
