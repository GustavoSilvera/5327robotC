#pragma config(Sensor, in1,    Gyro,      		 sensorGyro)
#pragma config(Sensor, in2,    LockPot,       	 sensorGyro)
#pragma config(Sensor, in3,    BATERY_2_PORT, 	 sensorAnalog)
#pragma config(Sensor, in7,    RightLiftPot,  	 sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftBaseEnc,   	 sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBaseEnc,  	 sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LeftConveyerEnc,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  RightConveyerEnc, sensorQuadEncoder)
#pragma config(Motor,  port1,  RConveyerMotor,   tmotorVex393_HBridge,  openLoop)
#pragma config(Motor,  port3,  RBaseFront,   	 tmotorVex393_MC29, 	openLoop)
#pragma config(Motor,  port4,  RBaseBack,     	 tmotorVex393_MC29, 	openLoop)
#pragma config(Motor,  port5,  lockMotor,        tmotorVex393_MC29, 	openLoop)
#pragma config(Motor,  port7,  LBaseFront,    	 tmotorVex393_MC29, 	openLoop)
#pragma config(Motor,  port8,  LBaseBack, 	     tmotorVex393_MC29, 	openLoop)
#pragma config(Motor,  port10, LConveyerMotor,   tmotorVex393_HBridge, 	openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!5
#include "Vex_Competition_Includes.c"

#define PI 3.1415

//controller
#define U5    		vexRT[Btn5U]//5U
#define D5	  		vexRT[Btn5D]//5D
#define U6  		vexRT[Btn6U]//6U
#define D6	  		vexRT[Btn6D]//6D
#define U7  		vexRT[Btn7U]//7U
#define D7	  		vexRT[Btn7D]//7D
#define L7    		vexRT[Btn7L]//7L
#define R7			vexRT[Btn7R]//7R
#define U8  		vexRT[Btn8U]//8U
#define D8	  		vexRT[Btn8D]//8D
#define L8    		vexRT[Btn8L]//8L
#define R8	  		vexRT[Btn8R]//8R
//partner controller
#define U5_2    	vexRT[Btn5UXmtr2]//5U2
#define D5_2	    vexRT[Btn5DXmtr2]//5D2
#define U6_2		vexRT[Btn6UXmtr2]//6U2
#define D6_2	    vexRT[Btn6DXmtr2]//622
#define U7_2  		vexRT[Btn7UXmtr2]//7U2
#define D7_2	    vexRT[Btn7DXmtr2]//7D2
#define L7_2    	vexRT[Btn7LXmtr2]//7L2
#define R7_2	    vexRT[Btn7RXmtr2]//7R2
#define U8_2  		vexRT[Btn8UXmtr2]//8U2
#define D8_2	    vexRT[Btn8DXmtr2]//8D2
#define L8_2    	vexRT[Btn8LXmtr2]//8L2
#define R8_2	    vexRT[Btn8RXmtr2]//8R2

#define LEFT true
#define RIGHT false

const float circum = 4 * PI;//4 inch wheels

struct PIDPar {
	char sensor;
	volatile int forceDirection;//changing with multiple threads
	int motor1, motor2, thresh;
	float kP, kI, kD;
	bool reversed, Mopposite;
	volatile bool isRunning;
	float Integral, Derivative, LastError;
};
enum Type { CONVEYER, DRIVE, FOURBAR };//what kinds of lift we have
struct sideMech {
	enum Type type;
	int motors[2];
	char sensor;
	float velocity, past;
	bool stalling;
};
struct sideMech conveyerR;
struct sideMech conveyerL;
struct sideMech baseRight;
struct sideMech baseLeft;
struct liftMech {
	int motors[2];
	char sensor;
	struct PIDPar PID;
	float velocity, past;
	int min, max, PIDelay;
	volatile float goal;
};
struct liftMech lock;
//other
volatile float mainVelocity = 0;
volatile float rotVelocity = 0;
volatile float pastRot;
static int currentAutonomous = 0;
volatile bool autonRunning = false;
string mainBattery, powerExpander;
//int startRot = 90;
volatile float mRot = 0.0;//current rotation
volatile float encoderAvg;//used only for straight fwds and bkwds direction
//MISC FUNCTIONS
int getSign(int check) {
	if (check < 0) return -1;
	else if (check > 0) return 1;
	return 0;
}
float limitUpTo(float max, float val) {
	if (abs(val) < abs(max)) return val;
	else return getSign(val) * max;
}
float limitDownTo(float min, float val) {
	if (abs(val) > abs(min)) return val;
	else return getSign(val) * min;
}
float sqr(float val) {
	return val*val;
}
float avg(float a, float b) {
	return 0.5*(a + b);//avg between two things
}
/********************************************************************************\
* .----------------.  .-----------------. .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |     _____    | || | ____  _____  | || |     _____    | || |  _________   | |*
*| |    |_   _|   | || ||_   \|_   _| | || |    |_   _|   | || | |  _   _  |  | |*
*| |      | |     | || |  |   \ | |   | || |      | |     | || | |_/ | | \_|  | |*
*| |      | |     | || |  | |\ \| |   | || |      | |     | || |     | |      | |*
*| |     _| |_    | || | _| |_\   |_  | || |     _| |_    | || |    _| |_     | |*
*| |    |_____|   | || ||_____|\____| | || |    |_____|   | || |   |_____|    | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/

void initMech(struct sideMech* mech, enum Type t, char sensor, int motre1, int motre2 = 0) {
	mech->type = t;
	mech->sensor = sensor;
	mech->motors[0] = motre1;
	mech->motors[1] = motre2;//defaulted to 0
	mech->velocity = 0.0;
	mech->past = 0.0;
	mech->stalling = false;
}
void initLift(struct liftMech* lift, char sensor, int motre1, int motre2, int min, int max, int delayamnt = 20) {
	lift->sensor = sensor;
	lift->motors[0] = motre1;
	lift->motors[1] = motre2;
	lift->min = min;
	lift->min = max;
	lift->velocity = 0.0;
	lift->past = 0.0;
	lift->goal = SensorValue[lift->sensor];
	lift->PIDelay = delayamnt;
}
void initPID(struct PIDPar* PIDType, char sensor, int thresh, float kP, float kI, float kD, bool reversed, bool isRunning) {
	PIDType->sensor = sensor;
	PIDType->thresh = thresh;
	PIDType->kP = kP;//0.2 //pretty efficient lift tho 0.075
	PIDType->kI = kI;// 0 .05;//0.04;
	PIDType->kD = kD;//1;
	PIDType->LastError = 0;
	PIDType->Integral = 0;
	PIDType->reversed = reversed;
	PIDType->isRunning = isRunning;
}
void scaleGyros() {
	SensorScale[Gyro] = 260;
	//Adjust SensorFullCount to set the "rollover" point. 3600 sets the rollover point to +/-3600
	//NO RESET
	SensorFullCount[Gyro] = 36000;
}
void resetGyros() {
	SensorType[in1] = sensorNone;
	SensorType[in1] = sensorGyro;//resets gyro sensor, rly sketchy
	SensorValue[Gyro] = 0;//resets gyro sensor
	delay(300);
	scaleGyros();
}
void initializeOpControl(bool driver) {
	clearLCDLine(0);
	clearLCDLine(1);
	if (driver) resetGyros();//wastes time on auton
		mainVelocity = 0.0;
	//--------&reference-------TYPE-----------sensor----------------motor1-------motor2--------(min, max)
	initMech( &conveyerL,	 CONVEYER,    LeftConveyerEnc,		LConveyerMotor							);//LEFT CONVEYER
	initMech( &conveyerR,	 CONVEYER,    RightConveyerEnc,		RConveyerMotor							);//RIGHT CONVEYER
	initMech( &baseLeft,	 DRIVE,	      LeftBaseEnc,			LBaseFront,		LBaseBack				);//LEFT BASE
	initMech( &baseRight,	 DRIVE,		  RightBaseEnc,			RBaseFront,		RBaseBack				);//RIGHT BASE
	initLift( &lock,					  LockPot,				lockMotor,		0,				0,	4095);//(min) && (max)
	initPID(  &lock.PID, lock.sensor, 30, 0.15, 0.0, 0.05, false, true);//threshold CAN be much lower, like 30
	pastRot = mRot;
}
//function for driving the robot
/*******************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   _____      | || |     _____    | || |  _________   | || |  _________   | |*
*| |  |_   _|     | || |    |_   _|   | || | |_   ___  |  | || | |  _   _  |  | |*
*| |    | |       | || |      | |     | || |   | |_  \_|  | || | |_/ | | \_|  | |*
*| |    | |   _   | || |      | |     | || |   |  _|      | || |     | |      | |*
*| |   _| |__/ |  | || |     _| |_    | || |  _| |_       | || |    _| |_     | |*
*| |  |________|  | || |    |_____|   | || | |_____|      | || |   |_____|    | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\*******************************************************************************/
void liftMove(struct liftMech* lift, float speed) {
	float power = limitUpTo(127, speed);
	motor[lift->motors[0]] = power;//up is fast
	motor[lift->motors[1]] = power;//up is fast
}
void resetPIDVals(struct PIDPar* pid) {
	pid->LastError = 0;
	pid->Integral = 0;
	pid->Derivative = 0;
}
float pidController(struct PIDPar* PIDtype, int goal) {
	float error = SensorValue[PIDtype->sensor] - goal;//calculate error
	if (abs(error) < PIDtype->thresh) error = 0;
	float untilIntegral = 100;//considered "low threshold" for potentiometers
	if (PIDtype->kI != 0) {//calculates integral (only at very end)
		if (abs(error) < untilIntegral) PIDtype->Integral += error;//used for averaging the integral amount, later in motor power divided by 25
		else PIDtype->Integral = 0;
	}
	else PIDtype->Integral = 0;
	// calculate the derivative
	PIDtype->Derivative = error - PIDtype->LastError;//change in errors
	PIDtype->LastError = error;
	// calculate drive (in this case, just for the lifts)
	int dir = 1;
	if (PIDtype->reversed) dir = -1;
	return dir * PIDtype->kP * error + PIDtype->kI * PIDtype->Integral + PIDtype->kD * PIDtype->Derivative;
	//return(dir * getSign(error) * abs((PIDtype->kP * error) + (PIDtype->kI * PIDtype->Integral) + (PIDtype->kD * PIDtype->Derivative)));
}
void PIDLift(struct liftMech* lift) {
	if (lift->PID.isRunning) liftMove(lift, pidController(lift->PID, lift->goal));//power the lift with its PID
	else resetPIDVals(lift->PID);//turn off the PID and reset values
		delay(lift->PIDelay);//delay a lil bit
}
void manualLiftControl(struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, bool reversed, int maxSpeed) {
	int dir = 1;
	if (reversed) dir = -1;
	bool upButton = (bUp == 1 || bUp2 == 1);//defining what is up button
	bool downButton = (bDown == 1 || bDown2 == 1);//defining what is down button
	if (!upButton && !downButton) liftMove(lift, 0);//not pressed any buttons
	else if ((SensorValue[lift->sensor] >= lift->max && (upButton))
		|| (SensorValue[lift->sensor] <= lift->min && (downButton)))//pressing buttons but surpassed limits
	liftMove(lift, 0);//power 0
	else if (upButton) liftMove(lift, dir * maxSpeed);//up max speed
	else if (downButton) liftMove(lift, dir * -maxSpeed);//down max speed
	else liftMove(lift, 0);
}
void LiftLift(struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, float velLimit) {
	if (bUp || bDown || bUp2 || bDown2) {
		lift->PID.isRunning = false;
		manualLiftControl(lift, bUp, bDown, bUp2, bDown2, false, 127);
	}
	else if (abs(SensorValue[lift->sensor] - lift->goal) < 200 || abs(lift->velocity) < velLimit) {
		if (!lift->PID.isRunning) lift->goal = SensorValue[lift->sensor];//sets goal if not already running
			lift->PID.isRunning = true;//now pid is definitely running
	}
	else {
		lift->PID.isRunning = false;
		liftMove(lift, 0);
	}
	PIDLift(lift);//calls the pid function for the lifts
}
void UpUntil(struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] < goal) {//brings lift up to goal
		liftMove(lift, speed);
	}
	lift->goal = SensorValue[lift->sensor];//keeps lift in last position
	lift->PID.isRunning = true;//re-enables pid
	return;
}
void DownUntil(struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] > goal) {//brings lift down to goal
		liftMove(lift, -speed);
	}
	lift->goal = SensorValue[lift->sensor];//keeps lift in last position
	lift->PID.isRunning = true;//re-enables pid
	return;
}
/*******************************************************************************\
*.----------------.  .----------------.  .----------------.  .----------------.  *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| | ____    ____ | || |  _________   | || |     ______   | || |  ____  ____  | |*
*| ||_   \  /   _|| || | |_   ___  |  | || |   .' ___  |  | || | |_   ||   _| | |*
*| |  |   \/   |  | || |   | |_  \_|  | || |  / .'   \_|  | || |   | |__| |   | |*
*| |  | |\  /| |  | || |   |  _|  _   | || |  | |         | || |   |  __  |   | |*
*| | _| |_\/_| |_ | || |  _| |___/ |  | || |  \ `.___.'\  | || |  _| |  | |_  | |*
*| ||_____||_____|| || | |_________|  | || |   `._____.'  | || | |____||____| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
*'----------------'  '----------------'  '----------------'  '----------------'  *
\*******************************************************************************/
float TruSpeed(float value) {//for all other polynomials; visit: goo.gl/mhvbx4
	return(getSign(value) * ((value*value) / (127)));//squaring
}//function for calculating the truSpeed function based off a polynomial
void mechMove(struct sideMech* mech, int speed) {
	motor[mech->motors[0]] = speed;//up is fast
	motor[mech->motors[1]] = speed;//up is fast
}
void manualMechControl(struct sideMech* side, int bUp, int bDown, int bUp2, int bDown2, bool reversed, int maxSpeed = 127) {
	int dir = 1;
	if (reversed) dir = -1;
	bool upButton = (bUp == 1 || bUp2 == 1);//defining what is up button
	bool downButton = (bDown == 1 || bDown2 == 1);//defining what is down button
	if (!upButton && !downButton) mechMove(side, 0);//not pressed any buttons
	else if (upButton) mechMove(side, dir * maxSpeed);//up max speed
	else if (downButton) mechMove(side, dir * -maxSpeed);//down max speed
	else mechMove(side, 0);
}
void baseDriveLR(int powerR, int powerL) {
	if (autonRunning) {
		if (!baseRight.stalling) mechMove(&baseRight, powerR);
		else {
			mechMove(&baseRight, 0);
			delay(750);//stall waiter
		}
		if (!baseLeft.stalling) mechMove(&baseLeft, powerL);
		else {
			mechMove(&baseLeft, 0);
			delay(750);//stall waiter
		}
	}
	else {//no antistall during manual
		mechMove(&baseRight, powerR);
		mechMove(&baseLeft, powerL);
	}
}
void driveCtrlr() {
	//scale for joystick
	const float partner = 0.8;
	const float primary = 1;
	baseDriveLR(//trusped taking both controllers
	TruSpeed(primary*vexRT[Ch2] + partner*vexRT[Ch2Xmtr2]),
	TruSpeed(primary*vexRT[Ch3] + partner*vexRT[Ch3Xmtr2])
	);
}
void fwds(int power, float angle) {//drive base forwards
	int speed = limitUpTo(127, power);
	const float scalar = 10;//scalar for rotation
	float dirSkew = limitUpTo(speed, scalar*(mRot - angle));
	baseDriveLR(speed - dirSkew, speed + dirSkew);
}
void rot(float speed) {//rotates base
	baseDriveLR(speed, -speed);
}
void driveFor(float goal) {//drives for certain inches
	SensorValue[LeftBaseEnc] = 0;
	SensorValue[RightBaseEnc] = 0;
	goal *= 2;//doubles "goal" not tuned very well as of rn
	const int thresh = 5;//10 ticks
	int initDir = mRot;
	//ClearTimer(T1);
	float dP = 20;//multiplier for velocity controller
	float vel = mainVelocity;
	while (abs(goal * circum - encoderAvg*0.25) > thresh) {
		fwds(limitDownTo(15, dP * ((goal*circum - encoderAvg*0.25 - 0.1*vel))), initDir);
	}
	fwds(0, initDir);
	return;
}
void rotFor(float rotGoal) {//rotates for certain degrees
	int rotScale = 1;//gyro is from -3600 to 3600 (NOT ANYMORE)
	const int thresh = 4 * rotScale;//4 degrees
	rotGoal *= rotScale;//scales to degrees
	int initial = mRot;
	float dP = 5;//multiplier for velocity controller
	int current = 0;//how much the robot has rotated
	while (abs(current - rotGoal) > thresh) {
		current = (mRot - initial);
		rot(dP * ((rotGoal - current - (mainVelocity * 0))));//SO GOOD
	}
	rot(0);
	return;
}
task MechControlTask() {
	for (;;) {//while true
		manualMechControl(&conveyerR, U6, D6, U6_2, D6_2, false);
		manualMechControl(&conveyerL, U6, D6, U6_2, D6_2, false);
		driveCtrlr();
		delay(10);
	}
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   ______     | || |  ____  ____  | || |  ____  ____  | || |    _______   | |*
*| |  |_   __ \   | || | |_   ||   _| | || | |_  _||_  _| | || |   /  ___  |  | |*
*| |    | |__) |  | || |   | |__| |   | || |   \ \  / /   | || |  |  (__ \_|  | |*
*| |    |  ___/   | || |   |  __  |   | || |    \ \/ /    | || |   '.___`-.   | |*
*| |   _| |_      | || |  _| |  | |_  | || |    _|  |_    | || |  |`\____) |  | |*
*| |  |_____|     | || | |____||____| | || |   |______|   | || |  |_______.'  | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
float calcVel(struct liftMech* lift, float dist, float delayAmount) {
	float velocity = ((SensorValue(lift->sensor) - lift->past) / dist) / ((float)(delayAmount / 1000));//1000ms in 1s
	lift->past = SensorValue[lift->sensor];
	return (velocity);//1000 ms in 1s;
}
float calcVel(struct sideMech* mech, float dist, float delayAmount) {
	float velocity = limitDownTo(1, ((SensorValue(mech->sensor) - mech->past) / dist) / ((float)(delayAmount / 1000)));//1000 ms in 1s;
	mech->past = SensorValue[mech->sensor];
	return(velocity);//1000 ms in 1s;
}
float calcRotVel() {
	float velocity = mRot - pastRot;
	pastRot = mRot;
	return(velocity);
}
task MeasureSpeed() {
	/*MEASURING IN IN/SEC*/
	float dist = 1.125*PI;
	float delayAmount = 50;
	for (;;) {
		//base & conveyer velocities
		baseRight.velocity = calcVel(&baseRight, circum, delayAmount);
		baseLeft.velocity = calcVel(&baseLeft, circum, delayAmount);
		conveyerR.velocity = calcVel(&conveyerR, circum, delayAmount);
		conveyerL.velocity = calcVel(&conveyerL, circum, delayAmount);
		//overall bot velocities
		mainVelocity = avg(baseRight.velocity, baseLeft.velocity);
		rotVelocity = calcRotVel();
		//lift velocity
		lock.velocity = calcVel(&lock, dist, delayAmount);
		//does the waitings
		delay(delayAmount);
	}
}//task for measuring velocity of the base, in IN/Sec
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |     ____     | || |  _________   | || |  ____  ____  | || |  _______     | |*
*| |   .'    `.   | || | |  _   _  |  | || | |_   ||   _| | || | |_   __ \    | |*
*| |  /  .--.  \  | || | |_/ | | \_|  | || |   | |__| |   | || |   | |__) |   | |*
*| |  | |    | |  | || |     | |      | || |   |  __  |   | || |   |  __ /    | |*
*| |  \  `--'  /  | || |    _| |_     | || |  _| |  | |_  | || |  _| |  \ \_  | |*
*| |   `.____.'   | || |   |_____|    | || | |____||____| | || | |____| |___| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
//for the cool ascii text go here: http://patorjk.com/software/taag/#p=display&f=Blocks
void displayAuton(int value, bool select = false) {
	// Cleat the lcd
	clearLCDLine(0);
	clearLCDLine(1);
	// Display the selection arrows
	displayLCDString(1, 0, "<--");
	displayLCDString(1, 13, "-->");
	// Save autonomous mode for later if selected
	if (select) currentAutonomous = value;//updates current auton with new
		// If this choice is selected then display ACTIVE
	if (currentAutonomous == value) displayLCDString(1, 5, "ACTIVE");
	else displayLCDString(1, 5, "select");
	// Simple selection display
	switch (value) {
	case    0:
		displayLCDString(0, 0, "3 Cone R");
		break;
	case    1:
		displayLCDString(0, 0, "3 Cone L");
		break;
	case    2:
		displayLCDString(0, 0, "1 Cone R");
		break;
	case    3:
		displayLCDString(0, 0, "1 Cone L");
		break;
	case    4:
		displayLCDString(0, 0, "RAM time");
		break;
	case    5:
		displayLCDString(0, 0, "no auton");
		break;
	default:
		displayLCDString(0, 0, "Unknown");
		break;
	}
}
void autonSelect(int delayTime = 5000) {
	clearTimer(T4);
	int value = 0;//no auton
	// here for reference http://help.robotc.net/Sandbox/Zendesk-Output/Content/Resources/topics/VEX_Cortex/ROBOTC/LCD_Display/nLCDButtons.htm
	const int LEFT = 1;
	const int RIGHT = 4;
	const int CENTER = 2;
	while (time1[T4] < delayTime) {
		// diaplay default choice
		displayAuton(value);
		// Display and select the autonomous routine
		if ((nLCDButtons == LEFT) || (nLCDButtons == RIGHT)) {
			// previous choice
			if (nLCDButtons == LEFT && value > 0)
				value--;
			// next choice
			if (nLCDButtons == RIGHT && value < 5)
				value++;
			displayAuton(value);//dosent say "ACTIVE"
			clearTimer(T4);
		}
		// Select this choice
		if (nLCDButtons == CENTER) {
			displayAuton(value, true);//says "ACTIVE"
			clearTimer(T4);
		}
		delay(200);
	}
}
void displayBatteryLevels() {
	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel / 1000.0, 'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);
	//Display the Power Expander voltage
	displayLCDString(1, 0, "PwrExpndr: ");
	sprintf(powerExpander, "%1.2f%c", ((float)SensorValue[BATERY_2_PORT] * 5.48 / 1000), 'V');//Build the value to be displayed
	displayNextLCDString(powerExpander);
}
task displayLCD() {
	for (;;) {
		if (nLCDButtons != 0) { //not sure if works (displays for 5 sec)
			autonSelect();
		}//displays auton for 5 seconds
		else displayBatteryLevels();
		delay(30);
	}
}
task sensorsUpdate() {
	//int rot=0;
	for (;;) {
		mRot = (int)((float)((15.0 / 8.0)*SensorValue[Gyro]));
		encoderAvg = avg(SensorValue[baseRight.sensor], SensorValue[baseLeft.sensor]);
		delay(5);//really quick delay
	}
}
bool stalling(const struct sideMech* mech) {
	return (
	abs(motor[mech->motors[0]]) > 100 &&//high ish power
	abs(motor[mech->motors[1]]) > 100 &&//high ish power
	abs(mech->velocity) < 50//low ish velocity yet high speed (for like 500 ms)
	);
}
void checkStalling(struct sideMech* mech) {
	if (stalling(mech)) {
		clearTimer(T1);
		bool currentlyStalling = true;
		while (time1[T1] < 400) {//checkingn for continuous stalling (else instantanious refresh)
			currentlyStalling = stalling(mech);//still stalling
			if (currentlyStalling) continue;//keep going until time limit
			else break;
		}
		if (currentlyStalling)//done waiting, final check
			mech->stalling = true;//if so, consider it stalling
	}
	else mech->stalling = false;
	if (mech->stalling) playSound(soundBlip);
}
task antiStall() {
	for (;;) {
		checkStalling(&baseRight);
		checkStalling(&baseLeft);
		checkStalling(&conveyerR);
		checkStalling(&conveyerL);
		delay(50);
	}
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .-----------------.*
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |      __      | || | _____  _____ | || |  _________   | || | ____  _____  | |*
*| |     /  \     | || ||_   _||_   _|| || | |  _   _  |  | || ||_   \|_   _| | |*
*| |    / /\ \    | || |  | |    | |  | || | |_/ | | \_|  | || |  |   \ | |   | |*
*| |   / ____ \   | || |  | |    | |  | || |     | |      | || |  | |\ \| |   | |*
*| | _/ /    \ \_ | || |   \ `--' /   | || |    _| |_     | || | _| |_\   |_  | |*
*| ||____|  |____|| || |    `.__.'    | || |   |_____|    | || ||_____|\____| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
	SensorType[Gyro] = sensorGyro;
	wait1Msec(2000);
	//Adjust SensorScale to correct the scaling for your gyro
	scaleGyros();
	while (bIfiRobotDisabled) {//in preauton
		autonSelect(nLCDButtons);
	}
}
task killswitch() {
	for (;;) {
		if (R7 && autonRunning) {
			stopAllTasks();
		}
		delay(50);
	}
}
void kamakaze() {//ram auton
	fwds(127, mRot);
	delay(5000);
	fwds(0, mRot);
	return;
}
task autonomous() {
	autonRunning = true;
	initializeOpControl(false);//auton init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(antiStall);
	switch (currentAutonomous) {
	case    0:
		//threeConeAuton(RIGHT);
		break;

	case    1:
		//threeConeAuton(LEFT);
		break;

	case    2:
		//EZAuton(RIGHT);
		break;

	case    3:
		//EZAuton(LEFT);
		break;

	case    4:
		//kamakaze();
		break;

	case    5://no auton
		break;

	default://no auton
		break;
	}

	return;
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| | _____  _____ | || |    _______   | || |  _________   | || |  _______     | |*
*| ||_   _||_   _|| || |   /  ___  |  | || | |_   ___  |  | || | |_   __ \    | |*
*| |  | |    | |  | || |  |  (__ \_|  | || |   | |_  \_|  | || |   | |__) |   | |*
*| |  | '    ' |  | || |   '.___`-.   | || |   |  _|  _   | || |   |  __ /    | |*
*| |   \ `--' /   | || |  |`\____) |  | || |  _| |___/ |  | || |  _| |  \ \_  | |*
*| |    `.__.'    | || |  |_______.'  | || | |_________|  | || | |____| |___| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
task usercontrol() {//initializes everything
	initializeOpControl(true);//driver init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(antiStall);
	startTask(killswitch);
	startTask(displayLCD);
	autonRunning = false;
	bLCDBacklight = true;// Turn on LCD Backlight
	clearLCDLine(0); // Clear line 1 (0) of the LCD
	clearLCDLine(1); // Clear line 2 (1) of the LCD
	for (;;) {
		//debug controls
		LiftLift(&lock, U5, D5, U5_2, D5_2, 180);
		delay(15);//~60hz
	}
}//function for operator control
