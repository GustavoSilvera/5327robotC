#pragma config(Sensor, in1,    RLin,           sensorNone)
#pragma config(Sensor, in2,    LLin,           sensorLineFollower)
#pragma config(Sensor, in3,    MLin,           sensorLineFollower)
#pragma config(Sensor, in5,    BATERY_2_PORT,  sensorAnalog)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  LeftBaseEnc,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBaseEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  MogoFront,      sensorTouch)
#pragma config(Sensor, dgtl6,  MogoEnd,        sensorTouch)
#pragma config(Sensor, dgtl8,  Lsonar,         sensorSONAR_cm)
#pragma config(Sensor, dgtl11, Rsonar,         sensorSONAR_cm)
#pragma config(Motor,  port2,           RConveyor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mtr,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LConveyor,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!5
#include "Vex_Competition_Includes.c"
#include "include/skills/randomstuff.h"
#include "include/skills/dataStructures.h"
#include "include/skills/mech.h"
#include "include/skills/PID.h"
#include "include/skills/lift.h"
#include "include/skills/other.h"
#include "include/skills/drive.h"
#include "include/skills/rotate.h"
#include "include/skills/physics.h"
#include "include/skills/init.h"

int startDir = 0;
void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
	SensorType[Gyro] = sensorGyro;
	wait1Msec(1220);
	//Adjust SensorScale to correct the scaling for your gyro
	scaleGyros();
	while (bIfiRobotDisabled) {//in preauton
		startTask(displayLCD);
	}
}
void initializeOpControl(const bool driver) {
	clearLCDLine(0);
	clearLCDLine(1);
	if (driver) resetGyros();//wastes time on auton
		mainVelocity = 0.0;
	resetEncoders();
	//--------&reference-------TYPE-----------sensor-----------motor1---------motor2-----//
	initMech( &conveyer,       CONVEY,        0,               LConveyor,     LConveyor   );//CONVEYOR
	initMech( &baseLeft,       DRIVE,         LeftBaseEnc,     LBaseFront,    LBaseBack   );//LEFT BASE
	initMech( &baseRight,      DRIVE,         RightBaseEnc,    RBaseFront,    RBaseBack   );//RIGHT BASE
	//--------&reference-------Sensor------------thresh---kP----kI---kD-----reversed---isRunning
	initPID(  &fourBar.PID,    fourBar.m.sensor, 50,      0.05, 0.0, 0.05,  true,      true);
	initPID(  &lock.PID,       lock.m.sensor,    30,      0.5,  0.0, 0.0,   true,      true);
	initPID(  &gyroBase,       Gyro,             1,       1,    0.0, 0,     true,      false);//kP = .35, kD = 0.6
	pastRot = mRot;
}
task intakeMogos(){
	//pick up first mogo
	while(SensorValue[MogoFront] == 0){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	while(SensorValue[MogoFront] == 1){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
	delay(500);
	//pick up second mogo
	while(SensorValue[MLin] > 150){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	while(SensorValue[MogoFront] == 0){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	delay(150);
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
	return;
}
task intakeMogo(){
	//intake one mogo, all the way at the top
	while(SensorValue[MogoEnd] == 0){
		//keep running conveyer
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	while(SensorValue[MogoEnd] == 1){
		//keep running conveyer
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
}
task conveyerMove(){
	stopTask(MechControlTask);
	for(;;){
		if(autonRunning) mechMove(&conveyer.m, conveyer.speed);//allows multitasking
			delay(50);
	}
}
task crossField() {
	//startTask(conveyerMove);
	//startTask(killswitch);
	conveyer.speed = INTAKE;
	startTask(intakeMogos);
	driveFor(110);
	rotEnc(135);
	return;
}
task skillsPart1() {
	startTask(conveyerMove);
	startTask(killswitch);
	//Corner Mogo (LOADER)
	startDir = mRot;
	motor[LConveyor] = INTAKE;
	motor[RConveyor] = INTAKE;
	startTask(intakeMogo);
	driveFor(60);//drive and grab mogo
	if( abs( startDir - mRot ) > 2) rotTune( startDir - mRot + 2);//angular correction
	driveFor(-58);//come back to 10pt pole
	RSwingFor(-40);//align with 10pt
	motor[LConveyor] = INTAKE;
	motor[RConveyor] = INTAKE;
	delay(400);//release mogo in 10pt

	//Cross Field
	startTask(intakeMogos);
	driveFor(110); //drive and intake 2 mogos
	rotEnc(130);

	//End
	startTask(MechControlTask);
}
task skillsPart2(){

	//Cross Field
	startTask(intakeMogos);
	driveFor(110); //intake mogos

	//Double Mogo Score
	rotEnc(120); //OPTIMIZE closer to left side of zone
	driveFor(-22); //drive to center
	LSwingFor(45); //swing to 10pt pole
	clearTimer(T4);
	while(time1(T4)<900) fwds(-127);//full power drive forward
	clearTimer(T4);
	while(time1(T4)<1000) {//outtake 20pt mogo
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	clearTimer(T4);
	while(time1(T4)<700) {//start driving out of 10pt
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
		fwds(127);
	}
	clearTimer(T4);//drive conveyor in case 2nd mogo doesn't outtake
	while(time1(T4)<200) {
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}

	//alignToLine(1);

	//End
	startTask(MechControlTask);
}
task skillsPart3() {

	//Align after double mogo
	alignToLine(1);
	driveFor(7);
	rotEnc(-90);
	delay(300);

	//Right Mogo
	driveToSonar(RIGHT, 12, 3); //drive to wall
	RSwingFor(30); //face mogo
	startDir = mRot;
	delay(200);
	startTask(intakeMogo);
	driveFor(10); //intake mogo
	alignToLine(1);
	driveFor(30);
	if( abs( startDir - mRot ) > 3) rotTune(0.5*(startDir - mRot));//angular correction
	driveFor(-55); //drive back
	LSwingFor(47); //align with 10pt
	clearTimer(T4);
	while(time1[T4]<400){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	delay(400);//release mogo in 10pt
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;

	//Align after right mogo
	alignToLine(1);
	driveFor(7);
	rotEnc(90);

	//Left Mogo
	driveToSonar(LEFT, 11, 3); //drive to wall
	LSwingFor(-35); //face mogo
	delay(200);
	startTask(intakeMogo);
	playSound(soundFastUpwardTones);
	driveFor(20);
	clearTimer(T4);
	playSound(soundFastUpwardTones);
	while(time1[T4]<100) { rot(127); }
	rot(0);
	resetencoders();
	delay(100);
	driveFor(25);
	playSound(soundFastUpwardTones);
	resetencoders();
	delay(100);
	driveFor(-25);
	clearTimer(T4);
	playSound(soundFastUpwardTones);
	while(time1[T4]<50){ rot(-127); }
	rot(0);
	resetencoders();
	delay(100);
	driveFor(-22);
	playSound(soundFastUpwardTones);
	RSwingFor(-40); //align with 10pt
	delay(300);
	clearTimer(T4);
	while(time1[T4]<400){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	delay(400);//release mogo in 10pt
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;

}
//repeat skills Part 2
task skillsPart4 () {

	//Align after double mogo
	alignToLine(1);
	driveFor(5);
	rotFor(-90);

	//Right Mogo
	driveToSonar(RIGHT, 10, 3); //drive to wall
	RSwingFor(43); //face mogo
	startTask(intakeMogo);
	driveFor(37); //intake mogo
	driveFor(-58); //drive back
	LSwingFor(45); //align with 10pt
	clearTimer(T4);
	while(time1[T4]<400){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	delay(400);//release mogo in 10pt

	//Park
	LSwingFor(-45);
	driveFor(60);
}
task autonomous(){}//nothing finalized yet
task usercontrol() {//initializes everything
	initializeOpControl(true);//driver init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	//startTask(antiStall); no
	startTask(killswitch);
	startTask(displayLCD);
	SensorValue[Gyro] = 0;//resets gyros
	SensorScale[Gyro] = 260;
	autonRunning = false;
	fourBar.goal = RELEASE;
	if(nImmediateBatteryLevel < 8500) playSound(soundException);
	else playSound(soundUpwardTones);

	for (;;) {
		//debug controls
		//do not use D7 -- killswitch
		/*if(R7) rotEnc(startDir - mRot);//angular correction
		if(L7) driveFor(50);*/
		if(L7) alignToLine(1);
		if(U7) LSwingFor(-45);
		if(R7) RSwingFor(-45);
		if(D7) RSwingFor(45);
		if(U5) startTask(skillsPart1);
		if(D5) startTask(skillsPart2);
		if(U8) startTask(skillsPart3);
		if(D8) startTask(skillsPart4);

		//accelerometer driving:
		/*
		float yaxis = 2*vexRT[AccelY];//drive
		float xaxis = 2*vexRT[AccelX];//rotate
		if(abs(yaxis) > abs(xaxis)){
			analogMechControl(&baseRight.m, -yaxis );
			analogMechControl(&baseLeft.m, -yaxis );
		}
		else{
			analogMechControl(&baseRight.m, -xaxis );
			analogMechControl(&baseLeft.m,   xaxis );
		}
		//if(abs(yaxis) > 20) 			fwds(-TruSpeed(yaxis));
		//else if(abs(xaxis) > 20)	rot(-TruSpeed(xaxis));
		*/
		delay(30);//~60hz
	}
}//function for operator control
