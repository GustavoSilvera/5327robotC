#pragma config(Sensor, in1,    RLin,           sensorNone)
#pragma config(Sensor, in2,    LLin,           sensorLineFollower)
#pragma config(Sensor, in3,    MLin,           sensorLineFollower)
#pragma config(Sensor, in5,    BATERY_2_PORT,  sensorAnalog)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  LeftBaseEnc,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBaseEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  MogoFront,      sensorTouch)
#pragma config(Sensor, dgtl6,  MogoEnd,        sensorTouch)
#pragma config(Sensor, dgtl8,  Lsonar,         sensorSONAR_cm)
#pragma config(Sensor, dgtl10, Rsonar,         sensorSONAR_cm)
#pragma config(Motor,  port2,           RConveyor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mtr,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LConveyor,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!5
#include "Vex_Competition_Includes.c"
#include "include/skills/randomstuff.h"
#include "include/skills/dataStructures.h"
#include "include/skills/mech.h"
#include "include/skills/PID.h"
#include "include/skills/lift.h"
#include "include/skills/other.h"
#include "include/skills/drive.h"
#include "include/skills/rotate.h"
#include "include/skills/physics.h"
#include "include/skills/init.h"

int startDir = 0;
void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
	SensorType[Gyro] = sensorGyro;
	wait1Msec(1220);
	//Adjust SensorScale to correct the scaling for your gyro
	scaleGyros();
	while (bIfiRobotDisabled) {//in preauton
		startTask(displayLCD);
	}
}
void initializeOpControl(const bool driver) {
	clearLCDLine(0);
	clearLCDLine(1);
	if (driver) resetGyros();//wastes time on auton
		mainVelocity = 0.0;
	resetEncoders();
	//--------&reference-------TYPE-----------sensor-----------motor1---------motor2-----//
	initMech( &conveyer,       CONVEY,        0,               LConveyor,     LConveyor   );//CONVEYOR
	initMech( &baseLeft,       DRIVE,         LeftBaseEnc,     LBaseFront,    LBaseBack   );//LEFT BASE
	initMech( &baseRight,      DRIVE,         RightBaseEnc,    RBaseFront,    RBaseBack   );//RIGHT BASE
	//--------&reference-------Sensor------------thresh---kP----kI---kD-----reversed---isRunning
	initPID(  &fourBar.PID,    fourBar.m.sensor, 50,      0.05, 0.0, 0.05,  true,      true);
	initPID(  &lock.PID,       lock.m.sensor,    30,      0.5,  0.0, 0.0,   true,      true);
	initPID(  &gyroBase,       Gyro,             1,       1,    0.0, 0,     true,      false);//kP = .35, kD = 0.6
	pastRot = mRot;
}
task intakeMogos(){
	//pick up first mogo
	while(SensorValue[MogoFront] == 0){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	while(SensorValue[MogoFront] == 1){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
	delay(500);
	//pick up second mogo
	while(SensorValue[MLin] > 150){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	while(SensorValue[MogoFront] == 0){
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	delay(150);
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
	return;
}
task intakeMogo(){
	//intake one mogo, all the way at the top
	while(SensorValue[MogoEnd] == 0){
		//keep running conveyer
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	while(SensorValue[MogoEnd] == 1){
		//keep running conveyer
		motor[LConveyor] = INTAKE;
		motor[RConveyor] = INTAKE;
	}
	playSound(soundBlip);
	motor[LConveyor] = 0;
	motor[RConveyor] = 0;
}
task conveyerMove(){
	stopTask(MechControlTask);
	for(;;){
		if(autonRunning) mechMove(&conveyer.m, conveyer.speed);//allows multitasking
			delay(50);
	}
}
task crossField() {
	//startTask(conveyerMove);
	//startTask(killswitch);
	conveyer.speed = INTAKE;
	startTask(intakeMogos);
	driveFor(110);
	rotEnc(135);
	return;
}
task skillsTest1() {
	startTask(conveyerMove);
	startTask(killswitch);
	//Corner Mogo
	startDir = mRot;
	motor[LConveyor] = INTAKE;
	motor[RConveyor] = INTAKE;
	startTask(intakeMogo);
	driveFor(60);//drive and grab mogo
	if( abs( startDir - mRot ) > 2) rotTune( startDir - mRot + 2);//angular correction
	driveFor(-58);//come back to 10pt pole
	RSwingFor(-40);//align with 10pt
	motor[LConveyor] = INTAKE;
	motor[RConveyor] = INTAKE;
	delay(200);//release mogo in 10pt
	//Cross Field
	startTask(intakeMogos);
	driveFor(110); //drive and intake 2 mogos
	rotEnc(135);
	//End
	startTask(MechControlTask);
}
task skillsTest2(){
	startTask(intakeMogos);
	driveFor(110);
	rotEnc(110);
	driveFor(-20);
	LSwingFor(-35);
	fwds(-127);//full power drive forward
	delay(700);
	motor[LConveyor] = INTAKE;
	motor[RConveyor] = INTAKE;
	delay(300);
	fwds(127);
	startTask(MechControlTask);
}
task autonomous(){}//nothing finalized yet
task usercontrol() {//initializes everything
	initializeOpControl(true);//driver init
	startTask(MechControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	//startTask(antiStall);
	//startTask(killswitch);
	startTask(displayLCD);
	SensorValue[Gyro] = 0;//resets gyros
	SensorScale[Gyro] = 260;
	autonRunning = false;
	fourBar.goal = RELEASE;
	if(nImmediateBatteryLevel < 8500) playSound(soundException);
	else playSound(soundUpwardTones);
	for (;;) {
		//debug controls
		if(R7) rotEnc(startDir - mRot);//driveFor(30); //startTask(intakeToLock);//(TUNED)
		if(L7) driveFor(50);//driveFor(-30);
		if(R8) RSwingFor(-45);
		if(L8) RSwingFor(45);
		if(U8) rotEnc(-90);
		if(D8) rotEnc(90);
		if(U5) startTask(skillsTest1);
		if(D5) startTask(skillsTest2);
		//accelerometer driving:
		/*
		float yaxis = 2*vexRT[AccelY];//drive
		float xaxis = 2*vexRT[AccelX];//rotate
		if(abs(yaxis) > abs(xaxis)){
			analogMechControl(&baseRight.m, -yaxis );
			analogMechControl(&baseLeft.m, -yaxis );
		}
		else{
			analogMechControl(&baseRight.m, -xaxis );
			analogMechControl(&baseLeft.m,   xaxis );
		}
		//if(abs(yaxis) > 20) 			fwds(-TruSpeed(yaxis));
		//else if(abs(xaxis) > 20)	rot(-TruSpeed(xaxis));
		*/
		delay(30);//~60hz
	}
}//function for operator control
