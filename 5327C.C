#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(Sensor, in1,    LeftGyro,       sensorGyro)
#pragma config(Sensor, in2,    RightGyro,      sensorGyro)
#pragma config(Sensor, in3,    FourBarPot,     sensorPotentiometer)
#pragma config(Sensor, in4,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    MoGoPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    BATERY_2_PORT,  sensorAnalog)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl10, PLoadLED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, OddLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, EvenLED,        sensorLEDtoVCC)
#pragma config(Motor,  port1,           R4Bar,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LiftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LMogo,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RMogo,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LiftBott,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          L4Bar,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
//#define PID_SENSOR_SCALE    1
#define PID_MOTOR_SCALE     -1
#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)
#define PID_INTEGRAL_LIMIT  50
#define PI 3.1415

//controller
#define U5    		vexRT[Btn5U]//5U
#define D5	  		vexRT[Btn5D]//5D
#define U6  			vexRT[Btn6U]//6U
#define D6	  		vexRT[Btn6D]//6D
#define U7  			vexRT[Btn7U]//7U
#define D7	  		vexRT[Btn7D]//7D
#define L7    		vexRT[Btn7L]//7L
#define R7				vexRT[Btn7R]//7R
#define U8  			vexRT[Btn8U]//8U
#define D8	  		vexRT[Btn8D]//8D
#define L8    		vexRT[Btn8L]//8L
#define R8	  		vexRT[Btn8R]//8R
//partner controller
#define U5_2    	vexRT[Btn5UXmtr2]//5U2
#define D5_2	    vexRT[Btn5DXmtr2]//5D2
#define U6_2			vexRT[Btn6UXmtr2]//6U2
#define D6_2	    vexRT[Btn6DXmtr2]//622
#define U7_2  		vexRT[Btn7UXmtr2]//7U2
#define D7_2	    vexRT[Btn7DXmtr2]//7D2
#define L7_2    	vexRT[Btn7LXmtr2]//7L2
#define R7_2	    vexRT[Btn7RXmtr2]//7R2
#define U8_2  		vexRT[Btn8UXmtr2]//8U2
#define D8_2	    vexRT[Btn8DXmtr2]//8D2
#define L8_2    	vexRT[Btn8LXmtr2]//8L2
#define R8_2	    vexRT[Btn8RXmtr2]//8R2
float circum = 4 * PI;//4 inch wheels
struct PIDPar {
	char sensor;
	volatile int forceDirection;//changing with multiple threads
	int motor1, motor2, thresh;
	float kP, kI, kD;
	bool reversed, Mopposite;
	volatile bool isRunning;
	float Integral, Derivative, LastError;
};
struct liftMech {
	int motors[2];
	char sensor;
	int max, min, liftPIDelay, past;
	PIDPar PID;
	volatile int goal;
	float velocity;
};
struct liftMech mainLift;
struct liftMech FourBar;
struct liftMech MoGo;
struct position {
	float X, Y, angle;//current x&y positions, and angle
};
struct position current;
struct position goal;
struct baseSide{
	int motors[2];
	char sensor;
	float velocity;
	bool stalling;
	float past;
};
struct baseSide Left;
struct baseSide Right;

//other
volatile float velocity;
volatile float mRot;//current rotation
volatile float encoderAvg;//used only for straight fwds and bkwds direction
//MISC FUNCTIONS
int getSign(int check) {
	if (check < 0) return -1;
	else if (check > 0) return 1;
	return 0;
}
float limitUpTo(float max, float val) {
	if (abs(val) < abs(max)) return val;
	else return getSign(val) * max;
}
float limitDownTo(float min, float val) {
	if (abs(val) > abs(min)) return val;
	else return getSign(val) * min;
}
float sqr(float val){
	return val*val;
}
float avg(float a, float b){
	return 0.5*(a+b);//avg between two things
}
/********************************************************************************\
* .----------------.  .-----------------. .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |     _____    | || | ____  _____  | || |     _____    | || |  _________   | |*
*| |    |_   _|   | || ||_   \|_   _| | || |    |_   _|   | || | |  _   _  |  | |*
*| |      | |     | || |  |   \ | |   | || |      | |     | || | |_/ | | \_|  | |*
*| |      | |     | || |  | |\ \| |   | || |      | |     | || |     | |      | |*
*| |     _| |_    | || | _| |_\   |_  | || |     _| |_    | || |    _| |_     | |*
*| |    |_____|   | || ||_____|\____| | || |    |_____|   | || |   |_____|    | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
void initLiftType(struct liftMech* lift, char sensor, int m1, int m2, int max, int min, int delayAmnt) {
	lift->sensor = sensor;
	lift->motors[0] = m1;
	lift->motors[1] = m2;
	lift->max = max;
	lift->min = min;
	lift->liftPIDelay = delayAmnt;
	lift->velocity = 0.0;
	lift->past = 0;
}
void initPID(struct PIDPar* PIDType, char sensor, int thresh, float kP, float kI, float kD, int lastError, int Integral, bool reversed, bool isRunning) {
	PIDType->sensor = sensor;
	PIDType->thresh = thresh;
	PIDType->kP = kP;//0.2 //pretty efficient lift tho 0.075
	PIDType->kI = kI;// 0 .05;//0.04;
	PIDType->kD = kD;//1;
	PIDType->LastError = lastError;
	PIDType->Integral = Integral;
	PIDType->reversed = reversed;
	PIDType->isRunning = isRunning;
}
void initBaseSide(struct baseSide* side, char sensor, int m1, int m2){
	side->sensor = sensor;
	side->motors[0] = m1;
	side->motors[1] = m2;
	side->velocity = 0;//initially not moving
	side->stalling = false;//initially not stalling (i hope)
	SensorValue[side->sensor] = 0;//initially resets encoders
	side->past = 0;
}
void resetGyros() {
	SensorType[in1] = sensorNone;
	SensorType[in1] = sensorGyro;//resets gyro sensor, rly sketchy
	SensorValue[LeftGyro] = 0;//resets gyro sensor
	SensorType[in2] = sensorNone;
	SensorType[in2] = sensorGyro;//resets gyro sensor, rly sketchy
	SensorValue[RightGyro] = 0;//resets gyro sensor
	delay(300);
}
void initializeOpControl() {
	SensorValue[EvenLED] = 0;
	SensorValue[OddLED] = 0;
	clearLCDLine(0);
	clearLCDLine(1);
	resetGyros();
	velocity = 0.0;
	////initializing lifts
	initLiftType(//MAIN LIFT
	&mainLift,//for MAIN DR4B
	LiftPot,
	LiftTop,
	LiftBott,
	4050, //lift max
	2100, //lift min
	20); //pid delay
	mainLift.goal = SensorValue[mainLift.sensor];
	initPID(&mainLift.PID, mainLift.sensor, 30, 0.35, 0.0, 0.0, 0, 0, true, true);//threshold CAN be much lower, like 30
	initLiftType(//FOURBAR
	&FourBar,//for MoGo
	FourBarPot,
	R4Bar,
	L4Bar,
	2600, //lift max
	900, //lift min
	20); //pid delay
	FourBar.goal = SensorValue[FourBar.sensor];
	initPID(&FourBar.PID, FourBar.sensor, 30, 0.15, 0.1, 0.01, 0, 0, true, true);
	initLiftType(//MOGO LIFT
	&MoGo,//for Four Bar
	MoGoPot,
	RMogo,
	LMogo,
	4050, //lift max
	2000, //lift min
	20); //pid delay
	MoGo.goal = SensorValue[MoGo.sensor];
	initPID(&MoGo.PID, MoGo.sensor, 30, 0.15, 0, 0, 0, 0, true, true);
	initBaseSide(
	&Left,
	LeftEncoder,
	LBaseFront,
	LBaseBack
	);
	initBaseSide(
	&Right,
	RightEncoder,
	RBaseFront,
	RBaseBack
	);
	current.X = 0;
	current.Y = 0;
	current.angle = 90;
}
//function for driving the robot
/*******************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   _____      | || |     _____    | || |  _________   | || |  _________   | |*
*| |  |_   _|     | || |    |_   _|   | || | |_   ___  |  | || | |  _   _  |  | |*
*| |    | |       | || |      | |     | || |   | |_  \_|  | || | |_/ | | \_|  | |*
*| |    | |   _   | || |      | |     | || |   |  _|      | || |     | |      | |*
*| |   _| |__/ |  | || |     _| |_    | || |  _| |_       | || |    _| |_     | |*
*| |  |________|  | || |    |_____|   | || | |_____|      | || |   |_____|    | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\*******************************************************************************/
void liftMove(struct liftMech* lift, int speed) {
	motor[lift->motors[0]] = speed;//up is fast
	motor[lift->motors[1]] = -speed;//up is fast
}
void resetPIDVals(struct PIDPar* pid) {
	pid->LastError = 0;
	pid->Integral = 0;
	pid->Derivative = 0;
}
float pidController(struct PIDPar* PIDtype, int goal) {
	float error = SensorValue[PIDtype->sensor] - goal;//calculate error
	if (abs(error) < PIDtype->thresh) error = 0;
	float untilIntegral = 100;//considered "low threshold" for potentiometers
	if (PIDtype->kI != 0) {//calculates integral (only at very end)
		if (abs(error) < untilIntegral) PIDtype->Integral += error;//used for averaging the integral amount, later in motor power divided by 25
		else PIDtype->Integral = 0;
	}
	else PIDtype->Integral = 0;
	// calculate the derivative
	PIDtype->Derivative = error - PIDtype->LastError;//change in errors
	PIDtype->LastError = error;
	// calculate drive (in this case, just for the robot)
	int dir = 1;
	if (PIDtype->reversed) dir = -1;
	return(dir * getSign(error) * abs((PIDtype->kP * error) + (PIDtype->kI * PIDtype->Integral) + (PIDtype->kD * PIDtype->Derivative)));
}
void PIDLift(struct liftMech* lift) {
	if (lift->PID.isRunning) {
		int power = pidController(lift->PID, lift->goal);
		liftMove(lift, power);
	}
	else {
		resetPIDVals(lift->PID);
	}
	delay(lift->liftPIDelay);
}
void manualLiftControl(struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, bool reversed, int maxSpeed) {
	int dir = 1;
	if (reversed) dir = -1;
	bool upButton = (bUp == 1 || bUp2 == 1);//defining what is up button
	bool downButton = (bDown == 1 || bDown2 == 1);//defining what is down button
	if (!upButton && !downButton) liftMove(lift, 0);//not pressed any buttons
	else if ((SensorValue[lift->sensor] >= lift->max && (upButton))
		|| (SensorValue[lift->sensor] <= lift->min && (downButton)))//pressing buttons but surpassed limits
	liftMove(lift, 0);//power 0
	else if (upButton) liftMove(lift, dir * maxSpeed);//up max speed
	else if (downButton) liftMove(lift, dir * -maxSpeed);//down max speed
	else liftMove(lift, 0);
}
void LiftLift(struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, float velLimit) {
	if (bUp || bDown || bUp2 || bDown2) {
		lift->PID.isRunning = false;
		manualLiftControl(lift, bUp, bDown, bUp2, bDown2, false, 127);
	}
	else {
		if (abs(SensorValue[lift->sensor] - lift->goal) < 200 || abs(lift->velocity) < velLimit) {
			if (!lift->PID.isRunning) {
				lift->goal = SensorValue[lift->sensor];
			}
			lift->PID.isRunning = true;
		}
		else {
			lift->PID.isRunning = false;
			liftMove(lift, 0);
		}
		//liftMove(MoGo, 0);
	}
}
void UpUntilStack(struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] < goal || SensorValue[sonar] <= 15) {//brings lift up to goal (ACCOUNTS FOR SONAR)
		liftMove(lift, speed);
	}
	return;
}
void UpUntil(struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] < goal) {//brings lift up to goal
		liftMove(lift, speed);
		//killswitch?
	}
	lift->goal = SensorValue[lift->sensor];//keeps lift in last position
	lift->PID.isRunning = true;
	return;
}
void DownUntil(struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] > goal) {//brings lift down to goal
		liftMove(lift, -speed);
		//killswitch?
	}
	lift->goal = SensorValue[lift->sensor];//keeps lift in last position
	lift->PID.isRunning = true;
	return;
}
task LiftControlTask() {
	for (;;) {//while true
		LiftLift(&mainLift, U6, D6, 0, 0, 180);
		PIDLift(&mainLift);
		LiftLift(&FourBar, U5, D5, U5_2, D5_2, 1200);
		PIDLift(&FourBar);
		LiftLift(&MoGo, D8, U8, D8_2, U8_2, 600);
		PIDLift(&MoGo);
		delay(10);
	}
}
/*******************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   ______     | || |      __      | || |    _______   | || |  _________   | |*
*| |  |_   _ \    | || |     /  \     | || |   /  ___  |  | || | |_   ___  |  | |*
*| |    | |_) |   | || |    / /\ \    | || |  |  (__ \_|  | || |   | |_  \_|  | |*
*| |    |  __'.   | || |   / ____ \   | || |   '.___`-.   | || |   |  _|  _   | |*
*| |   _| |__) |  | || | _/ /    \ \_ | || |  |`\____) |  | || |  _| |___/ |  | |*
*| |  |_______/   | || ||____|  |____|| || |  |_______.'  | || | |_________|  | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\*******************************************************************************/
float TruSpeed(float value) {//for all other polynomials; visit: goo.gl/mhvbx4
	return((value*value*value) / (127*127));
}//function for calculating the truSpeed function based off a polynomial
void baseMove(struct baseSide* side, int speed) {
	motor[side->motors[0]] = speed;//up is fast
	motor[side->motors[1]] = speed;//up is fast
}
void driveLR(int powerR, int powerL) {
	if(!Right.stalling) baseMove(&Right, powerR);
	else {
		baseMove(&Right, 0);
		delay(750);//stall waiter
	}
	if(!Left.stalling) baseMove(&Left, powerL);
	else {
		baseMove(&Left, 0);
		delay(750);//stall waiter
	}
}
void driveCtrlr() {
	//scale for joystick
	float partner = 0.6;
	float primary = 1;
	driveLR(//trusped taking both controllers
	TruSpeed(primary*vexRT[Ch2] + partner*vexRT[Ch2Xmtr2]),
	TruSpeed(primary*vexRT[Ch3] + partner*vexRT[Ch3Xmtr2])
	);
}
void fwds(int power, float angle) {//drive base forwards
	int speed = limitUpTo(100, power);
	float scalar = 10;//scalar for rotation
	float dirSkew = limitUpTo(speed, scalar*(mRot - angle));
	driveLR(speed - dirSkew, speed + dirSkew);
}
void rot(float speed) {//rotates base
	driveLR(speed, -speed);
}
void driveFor(float goal) {//drives for certain inches
	//works best from 1 to 40 ish.
	SensorValue[LeftEncoder] = 0;
	SensorValue[RightEncoder] = 0;
	goal *= 2;//doubles "goal" not tuned very well as of rn
	int thresh = 5;//10 ticks
	int initDir = mRot;
	//ClearTimer(T1);
	float dP = 20;//multiplier for velocity controller
	float vel = velocity;
	while (abs(goal * circum - encoderAvg) > thresh) {
		fwds(limitDownTo(15, dP * ((goal*circum - encoderAvg - 0.1*vel))), initDir);
	}
	fwds(0, initDir);
	return;
}
void rotFor(float rotGoal) {//rotates for certain degrees
	int rotScale = 1;//gyro is from -3600 to 3600 (NOT ANYMORE)
	int thresh = 4 * rotScale;//4 degrees
	rotGoal = getSign(rotGoal)*(abs(rotGoal) - 15);
	rotGoal *= rotScale;//scales to degrees
	int initial = mRot;
	float dP = 5;//multiplier for velocity controller
	int current = 0;//to not have to
	while (abs(current - rotGoal) > thresh) {
		current = abs(mRot - initial);
		if(abs(current - 360) < 3) {
			rotGoal = getSign(rotGoal)*(abs(rotGoal) - 360);
			current = 0;
		}
		rot(dP * ((rotGoal - abs(mRot - initial) - (velocity * 3)) * (10)));//SO GOOD
	}
	rot(0);
	return;
}
void goTo(struct position goal, struct position now) {
	float x = goal.X - (-now.X);
	float y = goal.Y - now.Y;
	float dist = sqrt(sqr(x) + sqr(y));
	float theta = atan(y / x) * (180.0/PI);
	//rotate to goal
	rotFor(now.angle-theta);
	rot(0);
	delay(500);
	//drive distance
	driveFor(dist);
	fwds(0, now.angle);
	delay(500);
	//rotate to desired angle
	rotFor(now.angle - goal.angle);
	rot(0);
	return;
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   ______     | || |  ____  ____  | || |  ____  ____  | || |    _______   | |*
*| |  |_   __ \   | || | |_   ||   _| | || | |_  _||_  _| | || |   /  ___  |  | |*
*| |    | |__) |  | || |   | |__| |   | || |   \ \  / /   | || |  |  (__ \_|  | |*
*| |    |  ___/   | || |   |  __  |   | || |    \ \/ /    | || |   '.___`-.   | |*
*| |   _| |_      | || |  _| |  | |_  | || |    _|  |_    | || |  |`\____) |  | |*
*| |  |_____|     | || | |____||____| | || |   |______|   | || |  |_______.'  | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
float calcLiftVel(const struct liftMech* lift, float dist, float delayAmount) {
	return ((SensorValue(lift->sensor) - lift->past) / dist) / ((float)(delayAmount / 1000));//1000 ms in 1s;
}
float calcBaseVel(const struct baseSide* side, float dist, float delayAmount) {
	return limitDownTo(1, ((SensorValue(side->sensor) - side->past) / dist) / ((float)(delayAmount / 1000)));//1000 ms in 1s;
}
task MeasureSpeed() {
	/*MEASURING IN IN/SEC*/
	float dist = 1.125*PI;
	float delayAmount = 50;
	for (;;) {
		//base velocity
		Right.velocity = calcBaseVel(&Right, circum, delayAmount);
		Right.past = SensorValue(Right.sensor);
		Left.velocity = calcBaseVel(&Left, circum, delayAmount);
		Left.past = SensorValue(Left.sensor);
		velocity = avg(Right.velocity, Left.velocity);//overall velocity (avdg between the two)
		//lift velocities
		mainLift.velocity = calcLiftVel(&mainLift, dist, delayAmount);
		mainLift.past = SensorValue(mainLift.sensor);
		FourBar.velocity = calcLiftVel(&FourBar, dist, delayAmount);
		FourBar.past = SensorValue(FourBar.sensor);
		MoGo.velocity = calcLiftVel(&MoGo, dist, delayAmount);
		MoGo.past = SensorValue(MoGo.sensor);
		//does the waitings
		delay(delayAmount);
	}
}//task for measuring velocity of the base, in IN/Sec
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |     ____     | || |  _________   | || |  ____  ____  | || |  _______     | |*
*| |   .'    `.   | || | |  _   _  |  | || | |_   ||   _| | || | |_   __ \    | |*
*| |  /  .--.  \  | || | |_/ | | \_|  | || |   | |__| |   | || |   | |__) |   | |*
*| |  | |    | |  | || |     | |      | || |   |  __  |   | || |   |  __ /    | |*
*| |  \  `--'  /  | || |    _| |_     | || |  _| |  | |_  | || |  _| |  \ \_  | |*
*| |   `.____.'   | || |   |_____|    | || | |____||____| | || | |____| |___| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
/*for the cool ascii text go here: http://patorjk.com/software/taag/#p=display&f=Blocks*/

task sensorsUpdate() {
	int rot=0;
	for (;;) {
		//i dont think the goTo function is working since the gyro rolls over at 360 degrees, thus when doing some rotations it cant make it completely and goes in infinite loop. all the maths are good tho.
		if(SensorValue[RightGyro] > 3550) {
			rot ++;
			SensorValue[RightGyro] = 0;
		}
		if(SensorValue[RightGyro] < -3550){
			rot --;
			SensorValue[RightGyro] = 0;
		}
		mRot = rot*getSign(SensorValue[RightGyro])*360 + (int)(SensorValue[RightGyro]/10);//0.5*(SensorValue[RightGyro] + SensorValue[LeftGyro]);
		encoderAvg = avg(SensorValue[Right.sensor], SensorValue[Left.sensor]);
		//encoderAvg = SensorValue[LeftEncoder];
		//figure out how to update the relative position
		current.angle = mRot + 90;//initially starts at 90 degrees
		current.X += velocity/circum * cos(current.angle * PI/180) * (PI/180);
		current.Y += velocity/circum * sin(current.angle * PI/180) * (PI/180);
		delay(1);//really quick delay
		//SensorValue[RightEncoder] = 0;
	}
}
bool stalling(const struct baseSide* side){
	return (
	abs(motor[side->motors[0]]) > 100 &&//high ish power
	abs(motor[side->motors[1]]) > 100 &&//high ish power
	abs(side->velocity) < 50//low ish velocity yet high speed (for like 500 ms)
	);
}
void checkStalling(struct baseSide* side){
	if(stalling(side)){
		clearTimer(T1);
		bool currentlyStalling = true;
		while(time1[T1] < 400){//checkingn for continuous stalling (else instantanious refresh)
			currentlyStalling = stalling(side);//still stalling
			if(currentlyStalling) continue;//keep going until time limit
			else break;
		}
		if(currentlyStalling)//done waiting, final check
			side->stalling = true;//if so, consider it stalling
	}
	else side->stalling = false;
	if(side->stalling) playSound(soundBlip);
}
task antiStall(){
	for(;;){
		checkStalling(&Right);
		checkStalling(&Left);
		delay(50);
	}
}
//gets last average potentiometer vals
task potAverage() {
	//POT averages
#define SAMPLE_SIZE 4
#define NUMSLOTS 4 // second slots
	int gFourBarPotSamples[SAMPLE_SIZE]; // number of samples keep at 2^x
	int gChainMA_Sum;
	int ind_c;
	int gChainMA;
	//initializing pot avgs
	for (int ind = 0; ind<SAMPLE_SIZE; ind++) {
		gFourBarPotSamples[ind] = 0;
	}
	ind_c = 0;
	gChainMA_Sum = 0;
	gChainMA = 0;
	for (;;) {
		// enter the routine with ind_c pointing to the val to be replace, ie oldest
		int oldest_val;
		oldest_val = gFourBarPotSamples[ind_c]; // save the oldest samples
		gChainMA_Sum -= oldest_val;
		gFourBarPotSamples[ind_c] = 10 * ((int)((float)SensorValue[FourBarPot] / 10)); // update with the latest sample (also rounded off)
		gChainMA_Sum += gFourBarPotSamples[ind_c];
		ind_c = (ind_c + 1) % SAMPLE_SIZE; // this is a circular buffer, update index
		gChainMA = gChainMA_Sum >> 2; // divide by 4
		delay(10);
		//abortTimeslice();
	}
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .-----------------.*
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |      __      | || | _____  _____ | || |  _________   | || | ____  _____  | |*
*| |     /  \     | || ||_   _||_   _|| || | |  _   _  |  | || ||_   \|_   _| | |*
*| |    / /\ \    | || |  | |    | |  | || | |_/ | | \_|  | || |  |   \ | |   | |*
*| |   / ____ \   | || |  | |    | |  | || |     | |      | || |  | |\ \| |   | |*
*| | _/ /    \ \_ | || |   \ `--' /   | || |    _| |_     | || | _| |_\   |_  | |*
*| ||____|  |____|| || |    `.__.'    | || |   |_____|    | || ||_____|\____| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
}
task autonomous() {
	initializeOpControl();
	startTask(potAverage);
	startTask(LiftControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	return;
}
int currentCone = 0;
task autoStack() {
	for (;;) {
		if (U7 && currentCone < 12) {
			mainLift.PID.isRunning = false;
			FourBar.PID.isRunning = false;
			int coneHeight = 150;//where to go
			int delayAmnt = 0;
			int initialHeight;//how much to go up and down once reached coneHeight's height
			if (currentCone == 0) {
				initialHeight = 400;
			}
			if (currentCone == 1) {
				initialHeight = 300;
				coneHeight = 160;
			}
			if (currentCone == 2) {
				initialHeight = 300;
			}
			if (currentCone == 3) {
				initialHeight = 350;
				coneHeight = 130;
			}
			if (currentCone == 4) {
				initialHeight = 370;
			}
			if (currentCone == 5) {
				initialHeight = 340;
				coneHeight = 130;
			}
			if (currentCone == 6) {
				initialHeight = 380;
			}
			//starts getting janky here
			if (currentCone == 7) {
				delayAmnt = 150;
				coneHeight = 130;
				initialHeight = 480;
			}
			if (currentCone == 8) {
				delayAmnt = 150;
				coneHeight = 150;
				initialHeight = 450;
			}
			if (currentCone == 9) {
				coneHeight = 170;
				delayAmnt = 240;
				initialHeight = 400;
			}
			if (currentCone == 10) {
				delayAmnt = 200;
				initialHeight = 420;
				coneHeight = 200;//basically bring to maximum (because limiter below)
			}
			UpUntilStack(mainLift, limitUpTo(mainLift.max, currentCone*coneHeight + mainLift.min + initialHeight), 127);
			//bring fourbar up
			delay(delayAmnt / 2);
			UpUntil(FourBar, FourBar.max, 127);
			//keep fourbar up
			FourBar.goal = FourBar.max;
			FourBar.PID.isRunning = true;
			delay(delayAmnt*0.75);
			//bring lift down
			DownUntil(mainLift, currentCone*coneHeight + mainLift.min, 127);
			//bring fourbar down
			FourBar.PID.isRunning = false;
			DownUntil(FourBar, FourBar.min, 127);
			//FourBar.goal = FourBar.min;
			currentCone++;//assumes got cone
		}
	}
}
void superMoGo() {
	FourBar.PID.isRunning = false;///bring 4bar down
	liftMove(&FourBar, -40);//do this WHILE bringing mogo OUT
	UpUntil(&MoGo, MoGo.max, 127);
	delay(300);
	UpUntil(&mainLift, limitUpTo(mainLift.max, SensorValue[mainLift.sensor] + 150), 127);//goes up a little bit (no more than maximum)
	UpUntil(&FourBar, FourBar.max, 127);//brings up four bar to let go
	driveFor(-5);//goes back a lil
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| | _____  _____ | || |    _______   | || |  _________   | || |  _______     | |*
*| ||_   _||_   _|| || |   /  ___  |  | || | |_   ___  |  | || | |_   __ \    | |*
*| |  | |    | |  | || |  |  (__ \_|  | || |   | |_  \_|  | || |   | |__) |   | |*
*| |  | '    ' |  | || |   '.___`-.   | || |   |  _|  _   | || |   |  __ /    | |*
*| |   \ `--' /   | || |  |`\____) |  | || |  _| |___/ |  | || |  _| |  \ \_  | |*
*| |    `.__.'    | || |  |_______.'  | || | |_________|  | || | |____| |___| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
task usercontrol() {//initializes everything
	initializeOpControl();
	startTask(potAverage);
	startTask(LiftControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(autoStack);
	startTask(antiStall);
	string mainBattery, powerExpander;
	bLCDBacklight = true;// Turn on LCD Backlight
	clearLCDLine(0); // Clear line 1 (0) of the LCD
	clearLCDLine(1); // Clear line 2 (1) of the LCD
	for (;;) {
		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);
		//Display the Power Expander voltage
		displayLCDString(1, 0, "PwrExpndr: ");
		sprintf(powerExpander, "%1.2f%c", ((float)SensorValue[ BATERY_2_PORT ] * 5.48/1000), 'V');//Build the value to be displayed
		displayNextLCDString(powerExpander);
		//debug controls
		if (D7) currentCone = 0;//reset
		if (L8) driveFor(70);//should have direction correction enabled
		if (R7) rotFor(70);//regular turning
		if (L7) {
			goal.X = 100;
			goal.Y = 100;
			goal.angle = 45;
			goTo(goal, current);
		}
		driveCtrlr();
		delay(15);//~60hz
	}
}//function for operator control
