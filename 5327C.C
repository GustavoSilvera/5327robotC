#pragma config(Sensor, in1,    LeftGyro,       sensorGyro)
#pragma config(Sensor, in2,    RightGyro,      sensorGyro)
#pragma config(Sensor, in3,    FourBarPot,     sensorPotentiometer)
#pragma config(Sensor, in4,    LeftLiftPot,    sensorPotentiometer)
#pragma config(Sensor, in5,    MoGoPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    BATERY_2_PORT,  sensorAnalog)
#pragma config(Sensor, in7,    RightLiftPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl11, OddLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, EvenLED,        sensorLEDtoVCC)
#pragma config(Motor,  port1,           R4Bar,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LiftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LMogo,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RMogo,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LiftLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          L4Bar,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!5
#include "Vex_Competition_Includes.c"
//#define PID_SENSOR_SCALE    1
#define PID_MOTOR_SCALE     -1
#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)
#define PID_INTEGRAL_LIMIT  50
#define PI 3.1415

//controller
#define U5    		vexRT[Btn5U]//5U
#define D5	  		vexRT[Btn5D]//5D
#define U6  		vexRT[Btn6U]//6U
#define D6	  		vexRT[Btn6D]//6D
#define U7  		vexRT[Btn7U]//7U
#define D7	  		vexRT[Btn7D]//7D
#define L7    		vexRT[Btn7L]//7L
#define R7			vexRT[Btn7R]//7R
#define U8  		vexRT[Btn8U]//8U
#define D8	  		vexRT[Btn8D]//8D
#define L8    		vexRT[Btn8L]//8L
#define R8	  		vexRT[Btn8R]//8R
//partner controller
#define U5_2    	vexRT[Btn5UXmtr2]//5U2
#define D5_2	    vexRT[Btn5DXmtr2]//5D2
#define U6_2		vexRT[Btn6UXmtr2]//6U2
#define D6_2	    vexRT[Btn6DXmtr2]//622
#define U7_2  		vexRT[Btn7UXmtr2]//7U2
#define D7_2	    vexRT[Btn7DXmtr2]//7D2
#define L7_2    	vexRT[Btn7LXmtr2]//7L2
#define R7_2	    vexRT[Btn7RXmtr2]//7R2
#define U8_2  		vexRT[Btn8UXmtr2]//8U2
#define D8_2	    vexRT[Btn8DXmtr2]//8D2
#define L8_2    	vexRT[Btn8LXmtr2]//8L2
#define R8_2	    vexRT[Btn8RXmtr2]//8R2

const float circum = 4 * PI;//4 inch wheels

struct PIDPar {
	char sensor;
	volatile int forceDirection;//changing with multiple threads
	int motor1, motor2, thresh;
	float kP, kI, kD;
	bool reversed, Mopposite;
	volatile bool isRunning;
	float Integral, Derivative, LastError;
};
enum liftType{BINARY, DUALSENSOR, NORMAL};//what kinds of lift we have
struct liftMech {
	enum liftType type;
	int motors[2];
	char sensor[2];
	float max, min, liftPIDelay, past;
	struct PIDPar PID;
	volatile float goal;
	float velocity;
};
struct liftMech mainLift;
struct liftMech FourBar;
struct liftMech MoGo;
//
struct position {
	float X, Y, angle;//current x&y positions, and angle
};
struct position initial;//used for GoTo
struct position current;
struct position goal;//used for GoTo

struct sideMech{
	int motors[2];
	char sensor;
	float velocity;
	bool stalling;
	float past;
};
struct sideMech Left;
struct sideMech Right;

//other
volatile float velocity = 0;
volatile float rotVelocity = 0;
volatile float pastRot;
int matchLoadConeIndex = 0;//minimum should always be three
int currentCone = 0;
volatile bool autonRunning = false;
volatile bool autoStacking = false;
volatile bool stopAutoStack = false;
//int startRot = 90;
volatile float mRot;//current rotation
volatile float encoderAvg;//used only for straight fwds and bkwds direction
//MISC FUNCTIONS
int getSign(int check) {
	if (check < 0) return -1;
	else if (check > 0) return 1;
	return 0;
}
float limitUpTo(float max, float val) {
	if (abs(val) < abs(max)) return val;
	else return getSign(val) * max;
}
float limitDownTo(float min, float val) {
	if (abs(val) > abs(min)) return val;
	else return getSign(val) * min;
}
float sqr(float val){
	return val*val;
}
float avg(float a, float b){
	return 0.5*(a+b);//avg between two things
}
/********************************************************************************\
* .----------------.  .-----------------. .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |     _____    | || | ____  _____  | || |     _____    | || |  _________   | |*
*| |    |_   _|   | || ||_   \|_   _| | || |    |_   _|   | || | |  _   _  |  | |*
*| |      | |     | || |  |   \ | |   | || |      | |     | || | |_/ | | \_|  | |*
*| |      | |     | || |  | |\ \| |   | || |      | |     | || |     | |      | |*
*| |     _| |_    | || | _| |_\   |_  | || |     _| |_    | || |    _| |_     | |*
*| |    |_____|   | || ||_____|\____| | || |    |_____|   | || |   |_____|    | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
void initLiftType(struct liftMech* lift, enum liftType type, char sensor, int m1, int m2, int max, int min, int delayAmnt) {
	lift->type = type;
	lift->sensor[0] = sensor;
	lift->sensor[1] = 0;//null second sensor (FOR ALL LIFTS OTHER THAN MAINLIFT)
	lift->motors[0] = m1;
	lift->motors[1] = m2;
	lift->max = max;
	lift->min = min;
	lift->liftPIDelay = delayAmnt;
	lift->velocity = 0.0;
	lift->past = 0;
}
void initPID(struct PIDPar* PIDType, char sensor, int thresh, float kP, float kI, float kD, int lastError, int Integral, bool reversed, bool isRunning) {
	PIDType->sensor = sensor;
	PIDType->thresh = thresh;
	PIDType->kP = kP;//0.2 //pretty efficient lift tho 0.075
	PIDType->kI = kI;// 0 .05;//0.04;
	PIDType->kD = kD;//1;
	PIDType->LastError = lastError;
	PIDType->Integral = Integral;
	PIDType->reversed = reversed;
	PIDType->isRunning = isRunning;
}
void initsideMech(struct sideMech* side, char sensor, int m1, int m2){
	side->sensor = sensor;
	side->motors[0] = m1;
	side->motors[1] = m2;
	side->velocity = 0;//initially not moving
	side->stalling = false;//initially not stalling (i hope)
	SensorValue[side->sensor] = 0;//initially resets encoders
	side->past = 0;
}
void resetGyros() {
	SensorType[in1] = sensorNone;
	SensorType[in1] = sensorGyro;//resets gyro sensor, rly sketchy
	SensorValue[LeftGyro] = 0;//resets gyro sensor
	SensorType[in2] = sensorNone;
	SensorType[in2] = sensorGyro;//resets gyro sensor, rly sketchy
	SensorValue[RightGyro] = 0;//resets gyro sensor
	delay(300);
}
void initializeOpControl() {
	SensorValue[EvenLED] = 0;
	SensorValue[OddLED] = 0;
	clearLCDLine(0);
	clearLCDLine(1);
	resetGyros();
	velocity = 0.0;
	////initializing lifts
	initLiftType(//MAIN LIFT
		&mainLift,//for MAIN DR4B
		DUALSENSOR,//for having two sensors
		LeftLiftPot,
		LiftRight, LiftLeft,//motors
		2150, 590, //(max & min)
		20//pid delay
	);
	mainLift.goal = SensorValue[mainLift.sensor[0]];
	mainLift.sensor[1] = RightLiftPot;
	initPID(&mainLift.PID, mainLift.sensor[0], 30, 0.35, 0.0, 0.01, 0, 0, true, true);//threshold CAN be much lower, like 30
	initLiftType(//FOURBAR
		&FourBar,//for Four Bar
		NORMAL,//only goes up and down (BINARY)
		FourBarPot,
		R4Bar,L4Bar,//motors
		2600, 900, //(max & min)
		10//pid delay
	);
	FourBar.goal = SensorValue[FourBar.sensor[0]];
	initPID(&FourBar.PID, FourBar.sensor[0], 30, 0.15, 0.0, 0.0, 0, 0, true, true);
	initLiftType(//MOGO LIFT
		&MoGo,//for MoGo
		NORMAL,//normal lift mech
		MoGoPot,
		RMogo,LMogo,//motors
		4050, 2000, //(max & min)
		20//pid delay
	);
	MoGo.goal = SensorValue[MoGo.sensor[0]];
	initPID(&MoGo.PID, MoGo.sensor[0], 30, 0.15, 0, 0, 0, 0, true, true);
	initsideMech(
		&Left,
		LeftEncoder,//sensor
		LBaseFront,	LBaseBack//motors
	);
	initsideMech(
		&Right,
		RightEncoder,//sensor
		RBaseFront,	RBaseBack//motors
	);
	current.X = 0;
	current.Y = 0;
	current.angle = 90;
	pastRot = mRot;
}
//function for driving the robot
/*******************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   _____      | || |     _____    | || |  _________   | || |  _________   | |*
*| |  |_   _|     | || |    |_   _|   | || | |_   ___  |  | || | |  _   _  |  | |*
*| |    | |       | || |      | |     | || |   | |_  \_|  | || | |_/ | | \_|  | |*
*| |    | |   _   | || |      | |     | || |   |  _|      | || |     | |      | |*
*| |   _| |__/ |  | || |     _| |_    | || |  _| |_       | || |    _| |_     | |*
*| |  |________|  | || |    |_____|   | || | |_____|      | || |   |_____|    | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\*******************************************************************************/
float PolyReg(float amnt){
	return(-11.237 * (amnt * amnt) + 286.05 * (amnt) + 261.23);
}
void liftMove(struct liftMech* lift, float speed) {
	float power = limitUpTo(127, speed);
	if(lift->sensor[1] != 0 && lift->type == DUALSENSOR){//HAS to be mainLift because has initialized 2nd sensor
		const float scalar = 0.05;//scalar for potentiometer difference
		float powSkew = limitUpTo(20, scalar*(PolyReg(SensorValue[mainLift.sensor[0]]) - SensorValue[mainLift.sensor[1]]));
		motor[lift->motors[0]] = power - powSkew;//one side goes faster/slower to compensate
		motor[lift->motors[1]] = -(power - powSkew);//one side goes faster/slower to compensate
	}
	else {
		motor[lift->motors[0]] = power;//up is fast
		motor[lift->motors[1]] = -power;//up is fast
	}
}
void resetPIDVals(struct PIDPar* pid) {
	pid->LastError = 0;
	pid->Integral = 0;
	pid->Derivative = 0;
}
float pidController(struct PIDPar* PIDtype, int goal) {
	float error = SensorValue[PIDtype->sensor] - goal;//calculate error
	if (abs(error) < PIDtype->thresh) error = 0;
	float untilIntegral = 100;//considered "low threshold" for potentiometers
	if (PIDtype->kI != 0) {//calculates integral (only at very end)
		if (abs(error) < untilIntegral) PIDtype->Integral += error;//used for averaging the integral amount, later in motor power divided by 25
		else PIDtype->Integral = 0;
	}
	else PIDtype->Integral = 0;
	// calculate the derivative
	PIDtype->Derivative = error - PIDtype->LastError;//change in errors
	PIDtype->LastError = error;
	// calculate drive (in this case, just for the lifts)
	int dir = 1;
	if (PIDtype->reversed) dir = -1;
	return dir * PIDtype->kP * error + PIDtype->kI * PIDtype->Integral + PIDtype->kD * PIDtype->Derivative;
	//return(dir * getSign(error) * abs((PIDtype->kP * error) + (PIDtype->kI * PIDtype->Integral) + (PIDtype->kD * PIDtype->Derivative)));
}
void PIDLift(struct liftMech* lift) {
	if (lift->PID.isRunning) liftMove(lift, pidController(lift->PID, lift->goal));//power the lift with its PID
	else resetPIDVals(lift->PID);//turn off the PID and reset values
		delay(lift->liftPIDelay);//delay a lil bit
}
void manualLiftControl(struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, bool reversed, int maxSpeed) {
	int dir = 1;
	if (reversed) dir = -1;
	bool upButton = (bUp == 1 || bUp2 == 1);//defining what is up button
	bool downButton = (bDown == 1 || bDown2 == 1);//defining what is down button
	if (!upButton && !downButton) liftMove(lift, 0);//not pressed any buttons
	else if ((SensorValue[lift->sensor] >= lift->max && (upButton))
		|| (SensorValue[lift->sensor] <= lift->min && (downButton)))//pressing buttons but surpassed limits
		liftMove(lift, 0);//power 0
	else if (upButton) liftMove(lift, dir * maxSpeed);//up max speed
	else if (downButton) liftMove(lift, dir * -maxSpeed);//down max speed
	else liftMove(lift, 0);
}
void LiftLift(struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, float velLimit) {
	if (bUp || bDown || bUp2 || bDown2) {
		lift->PID.isRunning = false;
		manualLiftControl(lift, bUp, bDown, bUp2, bDown2, false, 127);
	}
	else if(lift->type != BINARY){//BINARY IS ONLY TOP/BOTTOM
		if (abs(SensorValue[lift->sensor] - lift->goal) < 200 || abs(lift->velocity) < velLimit) {
			if (!lift->PID.isRunning) lift->goal = SensorValue[lift->sensor];//sets goal if not already running
				lift->PID.isRunning = true;//now pid is definitely running
		}
		else {
			lift->PID.isRunning = false;
			liftMove(lift, 0);
		}
		PIDLift(lift);//calls the pid function for the lifts
	}
}
void UpUntilStack(struct liftMech* lift, int goal, int speed) {//uses sonar for bringing lift up
	lift->PID.isRunning = false;
	int currentPos;
	while (SensorValue[lift->sensor] < goal || (SensorValue[sonar] <= 13 && SensorValue[sonar] >= 0)) {//brings lift up to goal (ACCOUNTS FOR SONAR)
		liftMove(lift, speed);
		currentPos = SensorValue[lift->sensor];
		if((U6 || U6_2)) break;
	}
	if(SensorValue[sonar] <= 15 && SensorValue[sonar] >= 0){
		while(SensorValue[lift->sensor] < currentPos + 150){
			liftMove(lift, speed);//moves a bit more if triggered sensor
		}
	}
	return;
}
void UpUntil(struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] < goal) {//brings lift up to goal
		liftMove(lift, speed);
		if((U6 || U6_2)) break;
		//killswitch?
	}
	lift->goal = SensorValue[lift->sensor];//keeps lift in last position
	lift->PID.isRunning = true;//re-enables pid
	return;
}
void DownUntil(struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] > goal ) {//brings lift down to goal
		liftMove(lift, -speed);
		if((U6 || U6_2)) break;
	}
	lift->goal = SensorValue[lift->sensor];//keeps lift in last position
	lift->PID.isRunning = true;//re-enables pid
	return;
}
task LiftControlTask() {
	for (;;) {//while true
		if(!autonRunning){
			mainLift.PID.kP = 0.35;
			LiftLift(&mainLift, U6, D6, U6_2, D6_2, 180);
			LiftLift(&FourBar, U5, D5, U5_2, D5_2, 1200);
			LiftLift(&MoGo, D8, U8, D8_2, U8_2, 600);
		}
		else {
			mainLift.PID.kP = 0.15;
			PIDLift(&mainLift);//calls the pid function for the lifts
			PIDLift(&FourBar);//calls the pid function for the lifts
			PIDLift(&MoGo);//calls the pid function for the lifts
		}
		delay(10);
	}
}
/*******************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   ______     | || |      __      | || |    _______   | || |  _________   | |*
*| |  |_   _ \    | || |     /  \     | || |   /  ___  |  | || | |_   ___  |  | |*
*| |    | |_) |   | || |    / /\ \    | || |  |  (__ \_|  | || |   | |_  \_|  | |*
*| |    |  __'.   | || |   / ____ \   | || |   '.___`-.   | || |   |  _|  _   | |*
*| |   _| |__) |  | || | _/ /    \ \_ | || |  |`\____) |  | || |  _| |___/ |  | |*
*| |  |_______/   | || ||____|  |____|| || |  |_______.'  | || | |_________|  | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\*******************************************************************************/
float TruSpeed(float value) {//for all other polynomials; visit: goo.gl/mhvbx4
	return(getSign(value) * ( (value*value) / (127) ));//squaring
}//function for calculating the truSpeed function based off a polynomial
void baseMove(struct sideMech* side, int speed) {
	motor[side->motors[0]] = speed;//up is fast
	motor[side->motors[1]] = speed;//up is fast
}
void driveLR(int powerR, int powerL) {
	if(autonRunning){
		if(!Right.stalling) baseMove(&Right, powerR);
		else {
			baseMove(&Right, 0);
			delay(750);//stall waiter
		}
		if(!Left.stalling) baseMove(&Left, powerL);
		else {
			baseMove(&Left, 0);
			delay(750);//stall waiter
		}
	}
	else{
		baseMove(&Right, powerR);
		baseMove(&Left, powerL);
	}
}
void driveCtrlr() {
	//scale for joystick
	const float partner = 0.8;
	const float primary = 1;
	driveLR(//trusped taking both controllers
		TruSpeed(primary*vexRT[Ch2] + partner*vexRT[Ch2Xmtr2]),
		TruSpeed(primary*vexRT[Ch3] + partner*vexRT[Ch3Xmtr2])
	);
}
void fwds(int power, float angle) {//drive base forwards
	int speed = limitUpTo(127, power);
	const float scalar = 10;//scalar for rotation
	float dirSkew = limitUpTo(speed, scalar*(mRot - angle));
	driveLR(speed - dirSkew, speed + dirSkew);
}
void rot(float speed) {//rotates base
	driveLR(speed, -speed);
}
void driveFor(float goal) {//drives for certain inches
	//works best from 1 to 40 ish.
	SensorValue[LeftEncoder] = 0;
	SensorValue[RightEncoder] = 0;
	goal *= 2;//doubles "goal" not tuned very well as of rn
	const int thresh = 5;//10 ticks
	int initDir = mRot;
	//ClearTimer(T1);
	float dP = 20;//multiplier for velocity controller
	float vel = velocity;
	while (abs(goal * circum - encoderAvg*0.25) > thresh) {
		fwds(limitDownTo(15, dP * ((goal*circum - encoderAvg*0.25 - 0.1*vel))), initDir);
	}
	fwds(0, initDir);
	return;
}
void rotFor(float rotGoal) {//rotates for certain degrees
	int rotScale = 1;//gyro is from -3600 to 3600 (NOT ANYMORE)
	const int thresh = 4 * rotScale;//4 degrees
	rotGoal *= rotScale;//scales to degrees
	int initial = mRot;
	float dP = 5;//multiplier for velocity controller
	int current = 0;//how much the robot has rotated
	while (abs(current - rotGoal) > thresh) {
		current = (mRot - initial);
		//if(abs(current - 360) < 3) {
		///	rotGoal = getSign(rotGoal)*(abs(rotGoal) - 360);
		//	current = 0;
		///}
		rot(dP * ((rotGoal - current - (velocity *0))));//SO GOOD
	}
	rot(0);
	return;
}
void goTo(struct position goal, struct position now) {
	float x = goal.X - (-now.X);
	float y = goal.Y - now.Y;
	float dist = sqrt(sqr(x) + sqr(y));
	float theta = atan(y / x) * (180.0/PI);
	//rotate to goal
	rotFor(now.angle-theta);
	rot(0);
	delay(500);
	//drive distance
	driveFor(dist);
	fwds(0, now.angle);
	delay(500);
	//rotate to desired angle
	rotFor(now.angle - goal.angle);
	rot(0);
	return;
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   ______     | || |  ____  ____  | || |  ____  ____  | || |    _______   | |*
*| |  |_   __ \   | || | |_   ||   _| | || | |_  _||_  _| | || |   /  ___  |  | |*
*| |    | |__) |  | || |   | |__| |   | || |   \ \  / /   | || |  |  (__ \_|  | |*
*| |    |  ___/   | || |   |  __  |   | || |    \ \/ /    | || |   '.___`-.   | |*
*| |   _| |_      | || |  _| |  | |_  | || |    _|  |_    | || |  |`\____) |  | |*
*| |  |_____|     | || | |____||____| | || |   |______|   | || |  |_______.'  | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
float calcVel(struct liftMech* lift, float dist, float delayAmount) {
	float velocity = ((SensorValue(lift->sensor) - lift->past) / dist) / ((float)(delayAmount / 1000));//1000ms in 1s
	lift->past = SensorValue[lift->sensor];
	return (velocity);//1000 ms in 1s;
}
float calcVel(struct sideMech* side, float dist, float delayAmount) {
	float velocity = limitDownTo(1, ((SensorValue(side->sensor) - side->past) / dist) / ((float)(delayAmount / 1000)));//1000 ms in 1s;
	side->past = SensorValue[side->sensor];
	return(velocity);//1000 ms in 1s;
}
float calcRotVel(){
	float velocity = SensorValue[RightGyro] - pastRot;
	pastRot = SensorValue[RightGyro];
	return(velocity);
}
task MeasureSpeed() {
	/*MEASURING IN IN/SEC*/
	float dist = 1.125*PI;
	float delayAmount = 50;
	for (;;) {
		//base velocity
		Right.velocity = calcVel(&Right, circum, delayAmount);
		Left.velocity = calcVel(&Left, circum, delayAmount);
		velocity = avg(Right.velocity, Left.velocity);//overall velocity (avdg between the two)
		rotVelocity = calcRotVel();//calculates rotational velocity
		//lift velocities
		mainLift.velocity = calcVel(&mainLift, dist, delayAmount);
		FourBar.velocity = calcVel(&FourBar, dist, delayAmount);
		MoGo.velocity = calcVel(&MoGo, dist, delayAmount);
		//does the waitings
		delay(delayAmount);
	}
}//task for measuring velocity of the base, in IN/Sec
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |     ____     | || |  _________   | || |  ____  ____  | || |  _______     | |*
*| |   .'    `.   | || | |  _   _  |  | || | |_   ||   _| | || | |_   __ \    | |*
*| |  /  .--.  \  | || | |_/ | | \_|  | || |   | |__| |   | || |   | |__) |   | |*
*| |  | |    | |  | || |     | |      | || |   |  __  |   | || |   |  __ /    | |*
*| |  \  `--'  /  | || |    _| |_     | || |  _| |  | |_  | || |  _| |  \ \_  | |*
*| |   `.____.'   | || |   |_____|    | || | |____||____| | || | |____| |___| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
/*for the cool ascii text go here: http://patorjk.com/software/taag/#p=display&f=Blocks*/

task sensorsUpdate() {
	int rot=0;
	for (;;) {
		//i dont think the goTo function is working since the gyro rolls over at 360 degrees, thus when doing some rotations it cant make it completely and goes in infinite loop. all the maths are good tho.
		///if(abs(rotVelocity) > 2500){
		//	rot += getSign(rotVelocity);
		//}
		mRot = rot*360 + (int)(SensorValue[RightGyro]/10);//0.5*(SensorValue[RightGyro] + SensorValue[LeftGyro]);
		encoderAvg = avg(SensorValue[Right.sensor], SensorValue[Left.sensor]);
		//encoderAvg = SensorValue[LeftEncoder];
		//figure out how to update the relative position
		current.angle = mRot + 90;//initially starts at 90 degrees
		current.X += velocity/circum * cos(current.angle * PI/180) * (PI/180);
		current.Y += velocity/circum * sin(current.angle * PI/180) * (PI/180);
		delay(1);//really quick delay
		//SensorValue[RightEncoder] = 0;
	}
}
bool stalling(const struct sideMech* side){
	return (
	abs(motor[side->motors[0]]) > 100 &&//high ish power
	abs(motor[side->motors[1]]) > 100 &&//high ish power
	abs(side->velocity) < 50//low ish velocity yet high speed (for like 500 ms)
	);
}
void checkStalling(struct sideMech* side){
	if(stalling(side)){
		clearTimer(T1);
		bool currentlyStalling = true;
		while(time1[T1] < 400){//checkingn for continuous stalling (else instantanious refresh)
			currentlyStalling = stalling(side);//still stalling
			if(currentlyStalling) continue;//keep going until time limit
			else break;
		}
		if(currentlyStalling)//done waiting, final check
			side->stalling = true;//if so, consider it stalling
	}
	else side->stalling = false;
	if(side->stalling) playSound(soundBlip);
}
task antiStall(){
	for(;;){
		checkStalling(&Right);
		checkStalling(&Left);
		delay(50);
	}
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .-----------------.*
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |      __      | || | _____  _____ | || |  _________   | || | ____  _____  | |*
*| |     /  \     | || ||_   _||_   _|| || | |  _   _  |  | || ||_   \|_   _| | |*
*| |    / /\ \    | || |  | |    | |  | || | |_/ | | \_|  | || |  |   \ | |   | |*
*| |   / ____ \   | || |  | |    | |  | || |     | |      | || |  | |\ \| |   | |*
*| | _/ /    \ \_ | || |   \ `--' /   | || |    _| |_     | || | _| |_\   |_  | |*
*| ||____|  |____|| || |    `.__.'    | || |   |_____|    | || ||_____|\____| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
}
task autonomous() {
	autonRunning = true;
	initializeOpControl();
	startTask(LiftControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(antiStall);
	autonRunning = false;
	return;
}
const int heightValues[11] = {170, 220, 370, 600, 750, 870, 1070, 1230, 1240, 1500, 1650};//values for where the lift should go to when autoStacking
const int coneHeight = 150;//how much the lift goes up DOWN after reaching height values
const int delayValues[11] = {50, 0, 0, 0, 0, 0, 0, 150, 100, 0, 0};//values for individual delays when autstacking
//const int delayValues[11] = {0, 0, 0, 0, 0, 0, 150, 150, 240, 200, 200};//values for individual delays when autstacking
const int fourBarMatchLoadPos = 2000;//get tru value
void matchLoads(int& coneIndex){//should be able to modify the variable (matchLoadConeIndex)
	const int matchLoadHeight = 2250;
	FourBar.PID.isRunning = true;
	FourBar.PID.kP = 0.5;
	FourBar.goal = fourBarMatchLoadPos;//IDEAL 4BAR POSITION FOR PICKUP
	DownUntil(&mainLift, matchLoadHeight, 127);//brings down to match loads thing
	delay(200);//grabs match load
	UpUntil(&mainLift, heightValues[coneIndex + 3] + mainLift.min, 127);//VALUE FOR LIFT BASED ON CONE
	UpUntil(&FourBar, FourBar.max, 90);
	DownUntil(&mainLift, heightValues[coneIndex + 3] + mainLift.min - (coneHeight+100), 127);//down a bit
	DownUntil(&FourBar, fourBarMatchLoadPos, 80);

	coneIndex++;//next cone
}
task autoStack() {
	for (;;) {
		if ((U7 || U7_2) && currentCone < 13) {
			autoStacking = true;
			FourBar.PID.kP = 0.15;
			mainLift.PID.isRunning = false;
			FourBar.PID.isRunning = true;
			//brings four bar up to prevent cone hitting mogo
			FourBar.goal = 0.5*(FourBar.min + FourBar.max);//brings up a bit
			delay(100);
			//brings lift up to value based on coneIndex
			UpUntil(&mainLift, limitUpTo(mainLift.max, heightValues[currentCone] + mainLift.min), 127);//USES SONAR
			FourBar.PID.isRunning = false;
			//bring fourbar up
			delay(delayValues[currentCone] * 0.75);
			UpUntil(&FourBar, FourBar.max, 127);
			//keep fourbar up
			FourBar.goal = FourBar.max;
			FourBar.PID.isRunning = true;
			delay(delayValues[currentCone] * 0.9);
			//bring lift down
			if(currentCone == 0)	DownUntil(&mainLift, heightValues[currentCone] + mainLift.min - (coneHeight + 70), 127);
			DownUntil(&mainLift, heightValues[currentCone] + mainLift.min - coneHeight, 127);

			//bring fourbar down
			FourBar.PID.isRunning = false;
			DownUntil(&FourBar, 2000, 127);
			delay(200);
		//	UpUntil(&FourBar, 1600, 127);//brings 4bar back up
			FourBar.PID.isRunning = true;
			currentCone++;//assumes got cone
			autoStacking = false;
		}

		if (D7 || D7_2) currentCone = 0;//reset
		if ((R8 || R8_2) && time1[T2]>300 && currentCone > 0) {
 			currentCone -= 1; //subtract one cone if autostack missed
 			playSound(soundBeepBeep);
 			clearTimer(T2);
 		}
 		//led stuff
 		if(currentCone % 2 == 0) {
 			SensorValue[EvenLED] = 1;//even led on
 			SensorValue[OddLED] = 0;
 		}
 		else if (currentCone == 11){
 			SensorValue[EvenLED] = 0;
 			SensorValue[OddLED] = 1;
 			delay(100);
 			SensorValue[EvenLED] = 1;
 			SensorValue[OddLED] = 0;
 			delay(100);
 		}
 		else {
 			SensorValue[EvenLED] = 0;
 			SensorValue[OddLED] = 1;//odd led on
 		}
 		//mogo thing
 		if ((R7 || R7_2) && !autonRunning){
 			MoGo.PID.isRunning = true;
 			liftMove(&MoGo, 100);
			delay(500);
			UpUntil(&MoGo, 2900, 50);
			liftMove(&MoGo, -30);
			delay(400);
			UpUntil(&MoGo, MoGo.max, 20);//sets power of 0, no PID
		}
 		delay(30);
	}
}
int initMRot;
task killswitch(){
	for(;;){
		if(R7 && autonRunning){
			stopAllTasks();
		}
		delay(50);
	}
}
void auton(){
	autonRunning = true;
	MoGo.goal = MoGo.max;//bring out mogo & drive
	MoGo.PID.isRunning = true;
	mainLift.goal = 0.5*(mainLift.max + mainLift.min) - 200;//bring up lift
	mainLift.PID.isRunning = true;
	FourBar.PID.kP = 0.01;//slow down four bar so cone doesn't fly out
	FourBar.goal = 1000;//four bar down
	FourBar.PID.isRunning = true;
	initMRot = mRot;
	delay(400);//wait for mogo to come out mostly
	driveFor(49);
	delay(300);
		//PRELOAD (MOGO WITH CONE)
	MoGo.goal = MoGo.min;
	delay(200);
	DownUntil(&mainLift, mainLift.min + 50, 127);//brings lift down
	delay(200);
	//CONE 2
  	mainLift.goal = mainLift.min + 400;
  	FourBar.PID.kP = 0.15;//return to normal kP value
  	UpUntil(&FourBar, FourBar.min + 400, 127);//brings lift up for next cone
	delay(200);
  	driveFor(3);
  	FourBar.goal = FourBar.min;
	DownUntil(&mainLift, mainLift.min, 127);//brings lift down (GRABBED CONE 1)
	delay(200);
	FourBar.goal = FourBar.max;//brings up lift to prepare stack
	UpUntil(&mainLift, mainLift.min + 300, 127);
	delay(100);
	driveFor(3);
	DownUntil(&mainLift, mainLift.min + 100, 127);//brings down lift
	FourBar.goal = FourBar.min;//															(RELEASED CONE 1)
	//UpUntil(&mainLift, mainLift.min + 300, 127);//brings lift up for next cone pickup
	driveFor(3);
	mainLift.PID.isRunning = true;
	mainLift.goal = SensorValue[mainLift.sensor[0]] + 200;
	delay(250);
	DownUntil(&FourBar, FourBar.min, 127);//ensures 4bar is down
	UpUntil(&mainLift, SensorValue[mainLift.sensor[0]] + 200, 127);
	DownUntil(&mainLift, mainLift.min, 127);//								(GRABBED CONE 2)
	delay(300);
	UpUntil(&mainLift, mainLift.min + 400, 127);
	UpUntil(&FourBar, FourBar.max, 127);
	DownUntil(&mainLift, mainLift.min + 200, 127);
	FourBar.goal = FourBar.min; //														(RELEASED CONE 2)
	if(abs(initMRot - mRot) > 3){
		rot(getSign(initMRot - mRot)*127);//checking direction if skewed too far
		delay(100);
	}
	FourBar.goal = 0.5*(FourBar.max + FourBar.min);//brings halfway
	driveFor(-66);//-53
	rotFor(-45);
	mainLift.goal = 0.5*(mainLift.min + mainLift.max)+200;//gets lift up and out of way
	driveFor(-25);//-32
	//position -135 degrees relative to starting position
	rotFor(-87);
	delay(200);
	MoGo.PID.kP = 0.05;
	MoGo.PID.isRunning = true;
	driveFor(6);
	MoGo.goal = 3000;
	fwds(60, mRot);//drive slowly
	delay(1000);
	driveFor(-20);
	MoGo.PID.kP = 0.15;
	autonRunning = false;
	return;
}
void autonLEFT(){
	autonRunning = true;
	MoGo.goal = MoGo.max;//bring out mogo & drive
	MoGo.PID.isRunning = true;
	mainLift.goal = 0.5*(mainLift.max + mainLift.min) - 200;//bring up lift
	mainLift.PID.isRunning = true;
	FourBar.PID.kP = 0.01;//slow down four bar so cone doesn't fly out
	FourBar.goal = 1000;//four bar down
	FourBar.PID.isRunning = true;
	initMRot = mRot;
	delay(400);//wait for mogo to come out mostly
	driveFor(49);
	delay(300);
		//PRELOAD (MOGO WITH CONE)
	MoGo.goal = MoGo.min;
	delay(200);
	DownUntil(&mainLift, mainLift.min + 50, 127);//brings lift down
	delay(200);
	//CONE 2
  	mainLift.goal = mainLift.min + 400;
  	FourBar.PID.kP = 0.15;//return to normal kP value
  	UpUntil(&FourBar, FourBar.min + 400, 127);//brings lift up for next cone
	delay(200);
  	driveFor(3);
  	FourBar.goal = FourBar.min;
	DownUntil(&mainLift, mainLift.min, 127);//brings lift down (GRABBED CONE 1)
	delay(200);
	FourBar.goal = FourBar.max;//brings up lift to prepare stack
	UpUntil(&mainLift, mainLift.min + 300, 127);
	delay(100);
	driveFor(3);
	DownUntil(&mainLift, mainLift.min + 100, 127);//brings down lift
	FourBar.goal = FourBar.min;//															(RELEASED CONE 1)
	//UpUntil(&mainLift, mainLift.min + 300, 127);//brings lift up for next cone pickup
	driveFor(2.5);
	mainLift.PID.isRunning = true;
	mainLift.goal = SensorValue[mainLift.sensor[0]] + 200;
	delay(250);
	DownUntil(&FourBar, FourBar.min, 127);//ensures 4bar is down
	UpUntil(&mainLift, SensorValue[mainLift.sensor[0]] + 200, 127);
	DownUntil(&mainLift, mainLift.min, 127);//								(GRABBED CONE 2)
	delay(300);
	UpUntil(&mainLift, mainLift.min + 400, 127);
	UpUntil(&FourBar, FourBar.max, 127);
	DownUntil(&mainLift, mainLift.min + 200, 127);
	FourBar.goal = FourBar.min; //														(RELEASED CONE 2)
	if(abs(initMRot - mRot) > 3){
		rot(getSign(initMRot - mRot)*-127);//checking direction if skewed too far
		delay(100);
	}
	FourBar.goal = 0.5*(FourBar.max + FourBar.min);//brings halfway
	driveFor(-66);//-53
	rotFor(45);
	mainLift.goal = 0.5*(mainLift.min + mainLift.max)+200;//gets lift up and out of way
	driveFor(-25);//-32
	//position -135 degrees relative to starting position
	rotFor(87);
	delay(200);
	MoGo.PID.kP = 0.05;
	MoGo.PID.isRunning = true;
	driveFor(6);
	MoGo.goal = 3000;
	fwds(70, mRot);//drive slowly
	delay(1200);
	driveFor(-20);
	MoGo.PID.kP = 0.15;
	autonRunning = false;
	return;
}

/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| | _____  _____ | || |    _______   | || |  _________   | || |  _______     | |*
*| ||_   _||_   _|| || |   /  ___  |  | || | |_   ___  |  | || | |_   __ \    | |*
*| |  | |    | |  | || |  |  (__ \_|  | || |   | |_  \_|  | || |   | |__) |   | |*
*| |  | '    ' |  | || |   '.___`-.   | || |   |  _|  _   | || |   |  __ /    | |*
*| |   \ `--' /   | || |  |`\____) |  | || |  _| |___/ |  | || |  _| |  \ \_  | |*
*| |    `.__.'    | || |  |_______.'  | || | |_________|  | || | |____| |___| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
task usercontrol() {//initializes everything
	initializeOpControl();
	startTask(LiftControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(autoStack);
	startTask(antiStall);
	startTask(killswitch);
	string mainBattery, powerExpander;
	bLCDBacklight = true;// Turn on LCD Backlight
	clearLCDLine(0); // Clear line 1 (0) of the LCD
	clearLCDLine(1); // Clear line 2 (1) of the LCD
	for (;;) {
		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);
		//Display the Power Expander voltage
		displayLCDString(1, 0, "PwrExpndr: ");
		sprintf(powerExpander, "%1.2f%c", ((float)SensorValue[ BATERY_2_PORT ] * 5.48/1000), 'V');//Build the value to be displayed
		displayNextLCDString(powerExpander);
		//debug controls
		if (L8 || L8_2) autonLEFT();//should have direction correction enabled
		if (L7) {
			matchLoads(matchLoadConeIndex);
		}
		driveCtrlr();
		delay(15);//~60hz
	}
}//function for operator control
