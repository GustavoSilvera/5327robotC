#pragma config(Sensor, in1,    Gyro,      	   sensorGyro)
#pragma config(Sensor, in3,    FourBarPot,     sensorPotentiometer)
#pragma config(Sensor, in4,    LeftLiftPot,    sensorPotentiometer)
#pragma config(Sensor, in5,    MoGoPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    BATERY_2_PORT,  sensorAnalog)
#pragma config(Sensor, in7,    RightLiftPot,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, OddLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, EvenLED,        sensorLEDtoVCC)
#pragma config(Motor,  port1,           R4Bar,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LiftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LMogo,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RMogo,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LiftLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          L4Bar,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!5
#include "Vex_Competition_Includes.c"

#define PI 3.1415

//controller
#define U5    		vexRT[Btn5U]//5U
#define D5	  		vexRT[Btn5D]//5D
#define U6  		vexRT[Btn6U]//6U
#define D6	  		vexRT[Btn6D]//6D
#define U7  		vexRT[Btn7U]//7U
#define D7	  		vexRT[Btn7D]//7D
#define L7    		vexRT[Btn7L]//7L
#define R7			vexRT[Btn7R]//7R
#define U8  		vexRT[Btn8U]//8U
#define D8	  		vexRT[Btn8D]//8D
#define L8    		vexRT[Btn8L]//8L
#define R8	  		vexRT[Btn8R]//8R
//partner controller
#define U5_2    	vexRT[Btn5UXmtr2]//5U2
#define D5_2	    vexRT[Btn5DXmtr2]//5D2
#define U6_2		vexRT[Btn6UXmtr2]//6U2
#define D6_2	    vexRT[Btn6DXmtr2]//622
#define U7_2  		vexRT[Btn7UXmtr2]//7U2
#define D7_2	    vexRT[Btn7DXmtr2]//7D2
#define L7_2    	vexRT[Btn7LXmtr2]//7L2
#define R7_2	    vexRT[Btn7RXmtr2]//7R2
#define U8_2  		vexRT[Btn8UXmtr2]//8U2
#define D8_2	    vexRT[Btn8DXmtr2]//8D2
#define L8_2    	vexRT[Btn8LXmtr2]//8L2
#define R8_2	    vexRT[Btn8RXmtr2]//8R2

#define LEFT true
#define RIGHT false

const float circum = 4 * PI;//4 inch wheels

struct PIDPar {
	char sensor;
	volatile int forceDirection;//changing with multiple threads
	int motor1, motor2, thresh;
	float kP, kI, kD;
	bool reversed, Mopposite;
	volatile bool isRunning;
	float Integral, Derivative, LastError;
};
struct PIDPar gyroBase;
enum liftType{BINARY, DUALSENSOR, NORMAL};//what kinds of lift we have
struct liftMech {
	enum liftType type;
	int motors[2];
	char sensor[2];
	float max, min, liftPIDelay, past;
	struct PIDPar PID;
	volatile float goal;
	float velocity;
};
struct liftMech mainLift;
struct liftMech FourBar;
struct liftMech MoGo;

struct sideMech{
	int motors[2];
	char sensor;
	float velocity;
	bool stalling;
	float past;
};
struct sideMech Left;
struct sideMech Right;

//other
volatile float velocity = 0;
volatile float rotVelocity = 0;
volatile float pastRot;
int currentCone = 0;
static const float GyroK = 15.0/80.0;//scales to normal +-360 degrees
static int currentAutonomous = 0;
volatile bool autonRunning = false;
volatile bool autoStacking = false;
volatile bool stopAutoStack = false;
string mainBattery, powerExpander;
//int startRot = 90;
volatile float mRot;//current rotation
volatile float encoderAvg;//used only for straight fwds and bkwds direction
//MISC FUNCTIONS
int getSign(const int check) {
	if (check < 0) return -1;
	else if (check > 0) return 1;
	return 0;
}
float limitUpTo(const float max, float val) {
	if (abs(val) < abs(max)) return val;
	else return getSign(val) * max;
}
float limitDownTo(const float min, const float val) {
	if (abs(val) > abs(min)) return val;
	else return getSign(val) * min;
}
float sqr(const float val){
	return val*val;
}
float avg(const float a, const float b){
	return 0.5*(a+b);//avg between two things
}
/********************************************************************************\
* .----------------.  .-----------------. .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |     _____    | || | ____  _____  | || |     _____    | || |  _________   | |*
*| |    |_   _|   | || ||_   \|_   _| | || |    |_   _|   | || | |  _   _  |  | |*
*| |      | |     | || |  |   \ | |   | || |      | |     | || | |_/ | | \_|  | |*
*| |      | |     | || |  | |\ \| |   | || |      | |     | || |     | |      | |*
*| |     _| |_    | || | _| |_\   |_  | || |     _| |_    | || |    _| |_     | |*
*| |    |_____|   | || ||_____|\____| | || |    |_____|   | || |   |_____|    | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
void initLiftType(const struct liftMech* lift, enum liftType type, char sensor, char sensor2, int m1, int m2, int max, int min, int delayAmnt = 20) {
	lift->type = type;
	lift->sensor[0] = sensor;
	lift->sensor[1] = sensor2;//null second sensor (FOR ALL LIFTS OTHER THAN MAINLIFT)
	lift->motors[0] = m1;
	lift->motors[1] = m2;
	lift->max = max;
	lift->min = min;
	lift->liftPIDelay = delayAmnt;
	lift->velocity = 0.0;
	lift->past = 0;
	lift->goal = SensorValue[lift->sensor[0]];
}
void initPID(const struct PIDPar* PIDType, char sensor, int thresh, float kP, float kI, float kD, bool reversed, bool isRunning = true) {
	PIDType->sensor = sensor;
	PIDType->thresh = thresh;
	PIDType->kP = kP;//0.2 //pretty efficient lift tho 0.075
	PIDType->kI = kI;// 0 .05;//0.04;
	PIDType->kD = kD;//1;
	PIDType->LastError = 0.0;
	PIDType->Integral = 0.0;
	PIDType->reversed = reversed;
	PIDType->isRunning = isRunning;
}
void initsideMech(const struct sideMech* side, char sensor, int m1, int m2){
	side->sensor = sensor;
	side->motors[0] = m1;
	side->motors[1] = m2;
	side->velocity = 0;//initially not moving
	side->stalling = false;//initially not stalling (i hope)
	SensorValue[side->sensor] = 0;//initially resets encoders
	side->past = 0;
}
void scaleGyros(){
	SensorScale[Gyro] = 260;
	//Adjust SensorFullCount to set the "rollover" point. 3600 sets the rollover point to +/-3600
	//NO RESET
	SensorFullCount[Gyro] = 36000;
}
void resetGyros() {
	SensorType[in1] = sensorNone;
	SensorType[in1] = sensorGyro;//resets gyro sensor, rly sketchy
	SensorValue[Gyro] = 0;//resets gyro sensor
	delay(300);
	scaleGyros();
}
void initializeOpControl(const bool driver) {
	SensorValue[EvenLED] = 0;
	SensorValue[OddLED] = 0;
	clearLCDLine(0);
	clearLCDLine(1);
	if(driver) resetGyros();//wastes time on auton
	velocity = 0.0;

	//-LIFT---------&reference--TYPE--------sensor-1--------sensor-2--------motor-1-----motor-2-----max------min----delay(opt)
	initLiftType(	&mainLift,	DUALSENSOR,	LeftLiftPot,	LeftLiftPot,	LiftRight,		LiftLeft, 	2150,	 	620	  );
	initLiftType(	&FourBar,	NORMAL,	 	FourBarPot,		0,					R4Bar,			L4Bar,		2550,	 	1400,	10);
	initLiftType(	&MoGo,		NORMAL,		MoGoPot,			0,					RMogo,			LMogo,		3735,	 	1120, 	  );

	//-PID------&reference------sensor----------------thresh----kP-------kI-----kD------reversed----running(opt)
	initPID(	&mainLift.PID,	mainLift.sensor[0],	  	  30,	      0.45,	   0.0,	 0.05, 	true, 		true);
	initPID(	&FourBar.PID, 	FourBar.sensor[0], 	     10, 	   0.1, 	   0.0,   0.01,   true, 		true);
	initPID(	&MoGo.PID, 		MoGo.sensor[0], 	  	     30, 	   0.15,    0.0,   0.0,    false, 		true);
	initPID ( &gyroBase, 	Gyro, 				0,  0.525, 0.0, 0.5, true, false);

	//-SIDE---------&reference----sensor------------motor-1-----------motor-2------
	initsideMech( 	&Left, 		  LeftEncoder, 		LBaseFront, 	  LBaseBack	);
	initsideMech( 	&Right, 	  	  RightEncoder,		RBaseFront,		  RBaseBack);
	pastRot = mRot;
}
//function for driving the robot
/*******************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   _____      | || |     _____    | || |  _________   | || |  _________   | |*
*| |  |_   _|     | || |    |_   _|   | || | |_   ___  |  | || | |  _   _  |  | |*
*| |    | |       | || |      | |     | || |   | |_  \_|  | || | |_/ | | \_|  | |*
*| |    | |   _   | || |      | |     | || |   |  _|      | || |     | |      | |*
*| |   _| |__/ |  | || |     _| |_    | || |  _| |_       | || |    _| |_     | |*
*| |  |________|  | || |    |_____|   | || | |_____|      | || |   |_____|    | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\*******************************************************************************/
float PolyReg(const float amnt){
	return(-11.237 * (amnt * amnt) + 286.05 * (amnt) + 261.23);
}
void liftMove(const struct liftMech* lift, const float speed) {
	float power = limitUpTo(127, speed);
	if(lift->sensor[1] != 0 && lift->type == DUALSENSOR){//HAS to be mainLift because has initialized 2nd sensor
		//const float scalar = 0.05;//scalar for potentiometer difference
		float powSkew = 0;//limitUpTo(20, scalar*(PolyReg(SensorValue[mainLift.sensor[0]]) - SensorValue[mainLift.sensor[1]]));
		motor[lift->motors[0]] = power - powSkew;//one side goes faster/slower to compensate
		motor[lift->motors[1]] = -(power - powSkew);//one side goes faster/slower to compensate
	}
	else {
		motor[lift->motors[0]] = power;//up is fast
		motor[lift->motors[1]] = -power;//up is fast
	}
}
void resetPIDVals(const struct PIDPar* pid) {
	pid->LastError = 0;
	pid->Integral = 0;
	pid->Derivative = 0;
}
float pidController(const struct PIDPar* PIDtype, const int goal) {
	float error = SensorValue[PIDtype->sensor] - goal;//calculate error
	if (abs(error) < PIDtype->thresh) error = 0;
	float untilIntegral = 100;//considered "low threshold" for potentiometers
	if (PIDtype->kI != 0) {//calculates integral (only at very end)
		if (abs(error) < untilIntegral) PIDtype->Integral += error;//used for averaging the integral amount, later in motor power divided by 25
		else PIDtype->Integral = 0;
	}
	else PIDtype->Integral = 0;
	// calculate the derivative
	PIDtype->Derivative = error - PIDtype->LastError;//change in errors
	PIDtype->LastError = error;
	// calculate drive (in this case, just for the lifts)
	int dir = 1;
	if (PIDtype->reversed) dir = -1;
	return dir * PIDtype->kP * error + PIDtype->kI * PIDtype->Integral + PIDtype->kD * PIDtype->Derivative;
	//return(dir * getSign(error) * abs((PIDtype->kP * error) + (PIDtype->kI * PIDtype->Integral) + (PIDtype->kD * PIDtype->Derivative)));
}
void PIDLift(const struct liftMech* lift) {
	if (lift->PID.isRunning) liftMove(lift, pidController(lift->PID, lift->goal));//power the lift with its PID
	else resetPIDVals(lift->PID);//turn off the PID and reset values
	delay(lift->liftPIDelay);//delay a lil bit
}
void manualLiftControl(const struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, bool reversed, int maxSpeed) {
	int dir = 1;
	if (reversed) dir = -1;
	bool upButton = (bUp == 1 || bUp2 == 1);//defining what is up button
	bool downButton = (bDown == 1 || bDown2 == 1);//defining what is down button
	if (!upButton && !downButton) liftMove(lift, 0);//not pressed any buttons
	else if ((SensorValue[lift->sensor] >= lift->max && (upButton))
		|| (SensorValue[lift->sensor] <= lift->min && (downButton)))//pressing buttons but surpassed limits
	liftMove(lift, 0);//power 0
	else if (upButton) liftMove(lift, dir * maxSpeed);//up max speed
	else if (downButton) liftMove(lift, dir * -maxSpeed);//down max speed
	else liftMove(lift, 0);
}
void LiftLift(const struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, float velLimit) {
	if (bUp || bDown || bUp2 || bDown2) {
		lift->PID.isRunning = false;
		manualLiftControl(lift, bUp, bDown, bUp2, bDown2, false, 127);
	}
	else if(lift->type != BINARY){//BINARY IS ONLY TOP/BOTTOM
		if (abs(SensorValue[lift->sensor] - lift->goal) < 200 || abs(lift->velocity) < velLimit) {
			if (!lift->PID.isRunning) lift->goal = SensorValue[lift->sensor];//sets goal if not already running
				lift->PID.isRunning = true;//now pid is definitely running
		}
		else {
			lift->PID.isRunning = false;
			liftMove(lift, 0);
		}
		PIDLift(lift);//calls the pid function for the lifts
	}
}
void UpUntil(const struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] < goal) {//brings lift up to goal
		liftMove(lift, speed);
		if(stopAutoStack) return;
	}
	lift->goal = SensorValue[lift->sensor];//keeps lift in last position
	lift->PID.isRunning = true;//re-enables pid
	return;
}
void DownUntil(struct liftMech* lift, int goal, int speed) {
	lift->PID.isRunning = false;
	while (SensorValue[lift->sensor] > goal ) {//brings lift down to goal
		liftMove(lift, -speed);
		if(stopAutoStack) return;
	}
	lift->goal = SensorValue[lift->sensor];//keeps lift in last position
	lift->PID.isRunning = true;//re-enables pid
	return;
}
task LiftControlTask() {
	for (;;) {//while true
		if(!autonRunning){
			mainLift.PID.kP = 0.35;
			LiftLift(&mainLift, U6, D6, U6_2, D6_2, 180);
			LiftLift(&FourBar, U5, D5, U5_2, D5_2, 1200);
			LiftLift(&MoGo, D8, U8, D8_2, U8_2, 600);
			/*if(SensorValue[MoGo.sensor[0]] > 2000){
				liftMove(&MoGo, -15);//keeps mogo down
			}*/
		}
		else {
			mainLift.PID.kP = 0.15;
			PIDLift(&mainLift);//calls the pid function for the lifts
			PIDLift(&FourBar);//calls the pid function for the lifts
			PIDLift(&MoGo);//calls the pid function for the lifts
		}
		delay(10);
	}
}
/*******************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   ______     | || |      __      | || |    _______   | || |  _________   | |*
*| |  |_   _ \    | || |     /  \     | || |   /  ___  |  | || | |_   ___  |  | |*
*| |    | |_) |   | || |    / /\ \    | || |  |  (__ \_|  | || |   | |_  \_|  | |*
*| |    |  __'.   | || |   / ____ \   | || |   '.___`-.   | || |   |  _|  _   | |*
*| |   _| |__) |  | || | _/ /    \ \_ | || |  |`\____) |  | || |  _| |___/ |  | |*
*| |  |_______/   | || ||____|  |____|| || |  |_______.'  | || | |_________|  | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\*******************************************************************************/
float TruSpeed(const float value) {//for all other polynomials; visit: goo.gl/mhvbx4
	return(getSign(value) * ( (value*value) / (127) ));//squaring
}//function for calculating the truSpeed function based off a polynomial
void baseMove(const struct sideMech* side, int speed) {
	motor[side->motors[0]] = speed;//up is fast
	motor[side->motors[1]] = speed;//up is fast
}
void driveLR(const int powerR, const int powerL) {
	if(autonRunning){
		if(!Right.stalling) baseMove(&Right, powerR);
		else {
			baseMove(&Right, 0);
			delay(750);//stall waiter
		}
		if(!Left.stalling) baseMove(&Left, powerL);
		else {
			baseMove(&Left, 0);
			delay(750);//stall waiter
		}
	}
	else{
		baseMove(&Right, powerR);
		baseMove(&Left, powerL);
	}
}
void driveCtrlr() {
	//scale for joystick
	const float partner = 1;//0.8;
	const float primary = 1;
	driveLR(//trusped taking both controllers
	TruSpeed(primary*vexRT[Ch2] + partner*vexRT[Ch2Xmtr2]),
	TruSpeed(primary*vexRT[Ch3] + partner*vexRT[Ch3Xmtr2])
	);
}
void fwds(const int power, const float angle) {//drive base forwards
	int speed = limitUpTo(127, power);
	const float scalar = 10;//scalar for rotation
	float dirSkew = limitUpTo(speed, scalar*(mRot - angle));
	driveLR(speed - dirSkew, speed + dirSkew);
}
void rot(const float speed) {//rotates base
	driveLR(speed, -speed);
}
void driveFor(float goal) {//drives for certain inches
	//works best from 1 to 40 ish.
	SensorValue[LeftEncoder] = 0;
	SensorValue[RightEncoder] = 0;
	goal *= 2;//doubles "goal" not tuned very well as of rn
	const int thresh = 5;//10 ticks
	int initDir = mRot;
	//ClearTimer(T1);
	float dP = 20;//multiplier for velocity controller
	float vel = velocity;
	while (abs(goal * circum - encoderAvg*0.25) > thresh) {
		fwds(limitDownTo(15, dP * ((goal*circum - encoderAvg*0.25 - 0.1*vel))), initDir);
	}
	fwds(0, initDir);
	return;
}
void rotFor(float target){
	gyroBase.isRunning = true;
	SensorValue[Gyro] = 0;//resets gyros
	SensorScale[Gyro] = 260;
	while(abs(SensorValue[Gyro]*GyroK - target) > 0.5){//2 dF
		rot(limitDownTo(15, pidController(&gyroBase, (target)/GyroK)));
	}
	rot(0);//gives settle time
	gyroBase.isRunning = false;
	resetPIDVals(&gyroBase);
	delay(target * 2);
	//check for overshoots
	const int slowPower = 60;
		while(SensorValue[Gyro]*GyroK > target + 0.5)
			rot(-abs(slowPower));
		while(SensorValue[Gyro]*GyroK < target - 0.5)
			rot(+abs(slowPower));
	rot(0);
	return;
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |   ______     | || |  ____  ____  | || |  ____  ____  | || |    _______   | |*
*| |  |_   __ \   | || | |_   ||   _| | || | |_  _||_  _| | || |   /  ___  |  | |*
*| |    | |__) |  | || |   | |__| |   | || |   \ \  / /   | || |  |  (__ \_|  | |*
*| |    |  ___/   | || |   |  __  |   | || |    \ \/ /    | || |   '.___`-.   | |*
*| |   _| |_      | || |  _| |  | |_  | || |    _|  |_    | || |  |`\____) |  | |*
*| |  |_____|     | || | |____||____| | || |   |______|   | || |  |_______.'  | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
float calcVel(const struct liftMech* lift, const float dist, const float delayAmount) {
	float velocity = ((SensorValue(lift->sensor) - lift->past) / dist) / ((float)(delayAmount / 1000));//1000ms in 1s
	lift->past = SensorValue[lift->sensor];
	return (velocity);//1000 ms in 1s;
}
float calcVel(const struct sideMech* side, const float dist, const float delayAmount) {
	float velocity = limitDownTo(1, ((SensorValue(side->sensor) - side->past) / dist) / ((float)(delayAmount / 1000)));//1000 ms in 1s;
	side->past = SensorValue[side->sensor];
	return(velocity);//1000 ms in 1s;
}
float calcRotVel(){
	float velocity = SensorValue[Gyro] - pastRot;
	pastRot = SensorValue[Gyro];
	return(velocity);
}
task MeasureSpeed() {
	/*MEASURING IN IN/SEC*/
	const float dist = 1.125*PI;
	const float delayAmount = 50;
	for (;;) {
		//base velocity
		Right.velocity = calcVel(&Right, circum, delayAmount);
		Left.velocity = calcVel(&Left, circum, delayAmount);
		velocity = avg(Right.velocity, Left.velocity);//overall velocity (avdg between the two)
		rotVelocity = calcRotVel();//calculates rotational velocity
		//lift velocities
		mainLift.velocity = calcVel(&mainLift, dist, delayAmount);
		FourBar.velocity = calcVel(&FourBar, dist, delayAmount);
		MoGo.velocity = calcVel(&MoGo, dist, delayAmount);
		//does the waitings
		delay(delayAmount);
	}
}//task for measuring velocity of the base, in IN/Sec
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |     ____     | || |  _________   | || |  ____  ____  | || |  _______     | |*
*| |   .'    `.   | || | |  _   _  |  | || | |_   ||   _| | || | |_   __ \    | |*
*| |  /  .--.  \  | || | |_/ | | \_|  | || |   | |__| |   | || |   | |__) |   | |*
*| |  | |    | |  | || |     | |      | || |   |  __  |   | || |   |  __ /    | |*
*| |  \  `--'  /  | || |    _| |_     | || |  _| |  | |_  | || |  _| |  \ \_  | |*
*| |   `.____.'   | || |   |_____|    | || | |____||____| | || | |____| |___| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
/*for the cool ascii text go here: http://patorjk.com/software/taag/#p=display&f=Blocks*/
void displayAuton( int value, bool select = false  ){
	// Cleat the lcd
	clearLCDLine(0);
	clearLCDLine(1);

	// Display the selection arrows
	displayLCDString(1,  0, "<--");
	displayLCDString(1, 13, "-->");
	// Save autonomous mode for later if selected
	if(select) currentAutonomous = value;//updates current auton with new
		// If this choice is selected then display ACTIVE
	if( currentAutonomous == value )
		displayLCDString(1, 5, "ACTIVE");
	else
		displayLCDString(1, 5, "select");

	// Simple selection display
	switch(value){
	case    0:
		displayLCDString(0, 0, "3 Cone R");
		break;
	case    1:
		displayLCDString(0, 0, "3 Cone L");
		break;
	case    2:
		displayLCDString(0, 0, "1 Cone R");
		break;
	case    3:
		displayLCDString(0, 0, "1 Cone L");
		break;
	case    4:
		displayLCDString(0, 0, "RAM time");
		break;
	case    5:
		displayLCDString(0, 0, "no auton");
		break;
	default:
		displayLCDString(0, 0, "Unknown");
		break;
	}

	// Save autonomous mode for later
	//currentAutonomous = value;
}
void autonSelect(int delayTime = 5000){
	clearTimer(T4);
	int value = 0;//no auton
	// here for reference http://help.robotc.net/Sandbox/Zendesk-Output/Content/Resources/topics/VEX_Cortex/ROBOTC/LCD_Display/nLCDButtons.htm
	const int LEFT = 1;
	const int RIGHT = 4;
	const int CENTER = 2;
	while(time1[T4] < delayTime){
		// diaplay default choice
		displayAuton(value);
		// Display and select the autonomous routine
		if( ( nLCDButtons == LEFT ) || ( nLCDButtons == RIGHT) ) {
			// previous choice
			if( nLCDButtons == LEFT && value > 0)
				value--;
			// next choice
			if( nLCDButtons == RIGHT && value < 5)
				value ++;
			displayAuton(value);//dosent say "ACTIVE"
			clearTimer(T4);
		}
		// Select this choice
		if( nLCDButtons == CENTER ) {
			displayAuton(value, true );//says "ACTIVE"
			clearTimer(T4);
		}
		delay(200);
	}
}
void displayBatteryLevels(){
	//Display the Primary Robot battery voltage
	displayLCDString(0, 0, "Primary: ");
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
	displayNextLCDString(mainBattery);
	//Display the Power Expander voltage
	displayLCDString(1, 0, "PwrExpndr: ");
	sprintf(powerExpander, "%1.2f%c", ((float)SensorValue[ BATERY_2_PORT ] * 5.48/1000), 'V');//Build the value to be displayed
	displayNextLCDString(powerExpander);
}
task displayLCD(){
	for(;;){
		if(nLCDButtons != 0) { //not sure if works (displays for 5 sec)
			autonSelect();
		}//displays auton for 5 seconds
		else displayBatteryLevels();
		delay(30);
	}
}
task sensorsUpdate() {
	//int rot=0;
	for (;;) {
		mRot = (float)((15.0/8.0)*SensorValue[Gyro]);
		encoderAvg = avg(SensorValue[Right.sensor], SensorValue[Left.sensor]);
		//encoderAvg = SensorValue[LeftEncoder];
		delay(5);//really quick delay
		//SensorValue[RightEncoder] = 0;
	}
}
bool stalling(const struct sideMech* side){
	return (
	abs(motor[side->motors[0]]) > 100 &&//high ish power
	abs(motor[side->motors[1]]) > 100 &&//high ish power
	abs(side->velocity) < 50//low ish velocity yet high speed (for like 500 ms)
	);
}
void checkStalling(struct sideMech* side){
	if(stalling(side)){
		clearTimer(T1);
		bool currentlyStalling = true;
		while(time1[T1] < 400){//checkingn for continuous stalling (else instantanious refresh)
			currentlyStalling = stalling(side);//still stalling
			if(currentlyStalling) continue;//keep going until time limit
			else break;
		}
		if(currentlyStalling)//done waiting, final check
			side->stalling = true;//if so, consider it stalling
	}
	else side->stalling = false;
	if(side->stalling) playSound(soundBlip);
}
task antiStall(){
	for(;;){
		checkStalling(&Right);
		checkStalling(&Left);
		delay(50);
	}
}
/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .-----------------.*
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| |      __      | || | _____  _____ | || |  _________   | || | ____  _____  | |*
*| |     /  \     | || ||_   _||_   _|| || | |  _   _  |  | || ||_   \|_   _| | |*
*| |    / /\ \    | || |  | |    | |  | || | |_/ | | \_|  | || |  |   \ | |   | |*
*| |   / ____ \   | || |  | |    | |  | || |     | |      | || |  | |\ \| |   | |*
*| | _/ /    \ \_ | || |   \ `--' /   | || |    _| |_     | || | _| |_\   |_  | |*
*| ||____|  |____|| || |    `.__.'    | || |   |_____|    | || ||_____|\____| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
	SensorType[Gyro] = sensorGyro;
	wait1Msec(2000);
	//Adjust SensorScale to correct the scaling for your gyro
	scaleGyros();
	while( bIfiRobotDisabled ){//in preauton...bIfiRobotDisabled ||
		autonSelect(nLCDButtons);
		delay(100);
	}
}
const int heightValues[11] = {220, 220, 370, 500, 620, 740, 830, 900, 1100, 1250, 1400};//values for where the lift should go to when autoStacking
const int coneHeight = 150;//how much the lift goes up DOWN after reaching height values
const int delayValues[11] = {400, 0, 0, 0, 0, 0, 100, 150, 100, 0, 0};//values for individual delays when autostacking
//const int delayValues[11] = {0, 0, 0, 0, 0, 0, 150, 150, 240, 200, 200};//values for individual delays when autstacking
task autoStack() {
	for (;;) {
		if ((U7 || U7_2) && currentCone < 11) {
			autoStacking = true;
			stopAutoStack = false;
			FourBar.PID.kP = 0.15;
			mainLift.PID.isRunning = false;
			FourBar.PID.isRunning = true;
			//brings four bar up to prevent cone hitting mogo
			FourBar.goal = 1700;//0.5*(FourBar.min + FourBar.max);//brings up a bit
			UpUntil(&FourBar, FourBar.min + 200, 127);
			delay(100);
			//brings lift up to value based on coneIndex
			UpUntil(&mainLift, limitUpTo(mainLift.max, heightValues[currentCone] + mainLift.min + 100), 127);
			FourBar.PID.isRunning = false;
			//bring fourbar up
			delay(delayValues[currentCone] * 0.75);
			UpUntil(&FourBar, FourBar.max, 127);
			//keep fourbar up
			FourBar.goal = FourBar.max;
			FourBar.PID.isRunning = false;
			delay(delayValues[currentCone] * 0.9);
			//bring lift down
			if(currentCone == 0)	DownUntil(&mainLift,mainLift.min, 127);
			DownUntil(&mainLift, heightValues[currentCone] + mainLift.min - coneHeight, 127);
			//bring fourbar down
			FourBar.PID.kP = 0.35;//keeps in place
			FourBar.goal = FourBar.max + 50;
			if(currentCone == 0) delay(200);
			DownUntil(&FourBar, FourBar.min, 127);
			//	UpUntil(&FourBar, 1600, 127);//brings 4bar back up
			FourBar.PID.isRunning = true;
			FourBar.PID.kP = 0.15;
			if(!stopAutoStack) currentCone++;//assumes got cone
				autoStacking = false;
		}
		if (D7 || D7_2) currentCone = 0;//reset
		if ((R8 || R8_2) && time1[T2]>300 && currentCone > 0) {
			currentCone -= 1; //subtract one cone if autostack missed
			playSound(soundDownwardTones);
			clearTimer(T2);
		}
		if ((L8 || L8_2) && time1[T3]>300 && currentCone < 11) {
			currentCone += 1; //add one cone
			playSound(soundUpwardTones);
			clearTimer(T3);
		}
		//led stuff
		if(currentCone % 2 == 0) {
			SensorValue[EvenLED] = 1;//even led on
			SensorValue[OddLED] = 0;
		}
		else if (currentCone == 11){
			SensorValue[EvenLED] = 0;
			SensorValue[OddLED] = 1;
			delay(100);
			SensorValue[EvenLED] = 1;
			SensorValue[OddLED] = 0;
			delay(100);
		}
		else {
			SensorValue[EvenLED] = 0;
			SensorValue[OddLED] = 1;//odd led on
		}
		//mogo thing
		if ((R7 || R7_2) && !autonRunning){
			//MoGo.goal = MoGo.min;
			//MoGo.PID.isRunning = true;
			DownUntil(&MoGo, 2500, -80);
			//liftMove(&MoGo, -20);
			delay(300);
			DownUntil(&MoGo, 1250, -20);

		}
		delay(30);
	}
}
int initMRot;
task killswitch(){
	for(;;){
		if(R7 && autonRunning){
			stopAllTasks();
		}
		if((D7 || D7_2) && autoStacking ) {//autostack killswitch
			stopAutoStack = true;
			stopTask(autoStack);
			playSound(soundBeepBeep);//killed autostack
			delay(100);
			startTask(autoStack);
		}
		delay(50);
	}
}
void kamakaze(){//ram auton
	fwds(127, mRot);
	delay(5000);
	fwds(0, mRot);
	return;
}
void twentyPointScore(const int dir){
	rotFor(-dir*45);
	mainLift.goal = 0.5*(mainLift.min + mainLift.max)+200;//gets lift up and out of way
	driveFor(-22);//-25 tho
	//position -135 degrees relative to starting position
	rotFor(-dir*90);//87 tho
	delay(200);
	MoGo.PID.kP = 0.05;
	MoGo.PID.isRunning = true;
	driveFor(6);
	MoGo.goal = 3000;
	fwds(90, mRot);//70
	delay(1000);
	driveFor(-15);
	MoGo.PID.kP = 0.15;
}
void fivePointScore(const int dir){
	rotFor(-dir*180);
	UpUntil(&MoGo, MoGo.min - 100, 127);
	driveFor(-15);
}
void threeConeAuton(const bool left){
	int dir = 1;//left auton
	if(left) dir = -1;
	autonRunning = true;
	MoGo.goal = MoGo.min;//bring out mogo & drive
	MoGo.PID.isRunning = true;
	mainLift.goal = 0.5*(mainLift.max + mainLift.min) - 200;//bring up lift
	mainLift.PID.isRunning = true;
	FourBar.PID.kP = 0.01;//slow down four bar so cone doesn't fly out
	FourBar.goal = 1000;//four bar down
	FourBar.PID.isRunning = true;
	initMRot = mRot;
	delay(400);//wait for mogo to come out mostly
	driveFor(49);
	delay(300);
	//PRELOAD (MOGO WITH CONE)
	MoGo.goal = MoGo.max;
	delay(200);
	DownUntil(&mainLift, mainLift.min + 50, 127);//brings lift down
	delay(200);
	//CONE 2
	mainLift.goal = mainLift.min + 400;
	FourBar.PID.kP = 0.15;//return to normal kP value
	UpUntil(&FourBar, FourBar.min + 400, 127);//brings lift up for next cone
	delay(200);
	driveFor(3);
	FourBar.goal = FourBar.min;
	DownUntil(&mainLift, mainLift.min, 127);//brings lift down (GRABBED CONE 1)
	delay(200);
	FourBar.goal = FourBar.max;//brings up lift to prepare stack
	UpUntil(&mainLift, mainLift.min + 300, 127);
	delay(100);
	driveFor(3);
	DownUntil(&mainLift, mainLift.min + 50, 127);//brings down lift
	FourBar.goal = FourBar.min;//															(RELEASED CONE 1)
	//UpUntil(&mainLift, mainLift.min + 300, 127);//brings lift up for next cone pickup
	driveFor(2);
	mainLift.PID.isRunning = true;
	mainLift.goal = SensorValue[mainLift.sensor[0]] + 200;
	delay(250);
	DownUntil(&FourBar, FourBar.min, 127);//ensures 4bar is down
	UpUntil(&mainLift, SensorValue[mainLift.sensor[0]] + 200, 127);
	DownUntil(&mainLift, mainLift.min, 127);//								(GRABBED CONE 2)
	delay(300);
	UpUntil(&mainLift, mainLift.min + 400, 127);
	UpUntil(&FourBar, FourBar.max, 127);
	DownUntil(&mainLift, mainLift.min + 200, 127);
	FourBar.goal = FourBar.min; //														(RELEASED CONE 2)
	if(abs(initMRot - mRot) > 3){
		rot(getSign(initMRot - mRot)*dir*127);//checking direction if skewed too far
		delay(100);
	}
	FourBar.goal = 0.5*(FourBar.max + FourBar.min);//brings halfway
	driveFor(-66);//-53
	twentyPointScore(dir);
	autonRunning = false;
	return;
}
void EZAuton(const bool left){
	int dir = 1;//left auton
	if(left) dir = -1;
	autonRunning = true;
	//MoGo.PID.kP = 0.;
	MoGo.goal = MoGo.min-300;//bring out mogo & drive
	MoGo.PID.isRunning = true;
	mainLift.goal = 1400;//bring up lift
	mainLift.PID.isRunning = true;
	FourBar.PID.kP = 0.05;//slow down four bar so cone doesn't fly out
	FourBar.goal = FourBar.min;//four bar down
	FourBar.PID.isRunning = true;
	initMRot = mRot;
	//MoGo.PID.kP
	delay(400);//wait for mogo to come out mostly
	driveFor(49);//49
	delay(300);
	//PRELOAD (MOGO WITH CONE)
	MoGo.goal = MoGo.max;
	delay(550);
	DownUntil(&mainLift, mainLift.min - 50, 127);//brings lift down
	FourBar.goal = 0.5*(FourBar.max + FourBar.min);//brings halfway
	delay(200);
	mainLift.goal = 0.5*(mainLift.min + mainLift.max);//brings halfway
	driveFor(-43);//-45
	twentyPointScore(dir);
	autonRunning = false;
	return;
}
task autonomous() {
	autonRunning = true;
	initializeOpControl(false);//auton init
	startTask(LiftControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(antiStall);
	switch( currentAutonomous ) {
	case    0:
		threeConeAuton(RIGHT);
		break;

	case    1:
		threeConeAuton(LEFT);
		break;

	case    2:
		EZAuton(RIGHT);
		break;

	case    3:
		EZAuton(LEFT);
		break;

	case    4:
		kamakaze();
		break;

	case    5://no auton
		break;

	default://no auton
		break;
	}

	return;
}


/********************************************************************************\
* .----------------.  .----------------.  .----------------.  .----------------. *
*| .--------------. || .--------------. || .--------------. || .--------------. |*
*| | _____  _____ | || |    _______   | || |  _________   | || |  _______     | |*
*| ||_   _||_   _|| || |   /  ___  |  | || | |_   ___  |  | || | |_   __ \    | |*
*| |  | |    | |  | || |  |  (__ \_|  | || |   | |_  \_|  | || |   | |__) |   | |*
*| |  | '    ' |  | || |   '.___`-.   | || |   |  _|  _   | || |   |  __ /    | |*
*| |   \ `--' /   | || |  |`\____) |  | || |  _| |___/ |  | || |  _| |  \ \_  | |*
*| |    `.__.'    | || |  |_______.'  | || | |_________|  | || | |____| |___| | |*
*| |              | || |              | || |              | || |              | |*
*| '--------------' || '--------------' || '--------------' || '--------------' |*
* '----------------'  '----------------'  '----------------'  '----------------' *
\********************************************************************************/
bool testing;
task usercontrol() {//initializes everything
	initializeOpControl(true);//driver init
	startTask(LiftControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(autoStack);
	startTask(antiStall);
	startTask(killswitch);
	startTask(displayLCD);
	autonRunning = false;
	bLCDBacklight = true;// Turn on LCD Backlight
	clearLCDLine(0); // Clear line 1 (0) of the LCD
	clearLCDLine(1); // Clear line 2 (1) of the LCD
	for (;;) {
		//debug controls
		if (L7 || L7_2 )EZAuton(RIGHT);
		//if (L7 || L7_2 )EZAuton(RIGHT);

		driveCtrlr();
		delay(15);//~60hz
	}
}//function for operator control
