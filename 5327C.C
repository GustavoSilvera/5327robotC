#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    LeftGyro,       sensorGyro)
#pragma config(Sensor, in2,    RightGyro,      sensorGyro)
#pragma config(Sensor, in3,    FourBarPot,     sensorPotentiometer)
#pragma config(Sensor, in4,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    MoGoPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl10, PLoadLED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, OddLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, EvenLED,        sensorLEDtoVCC)
#pragma config(Motor,  port1,           R4Bar,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LiftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LMogo,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RMogo,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LBaseFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBaseBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LiftBott,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          L4Bar,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// This code is for the VEX cortex platform
#pragma platform(VEX2)
// Select Download method as "competition"
#pragma competitionControl(Competition)
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
//#define PID_SENSOR_SCALE    1
#define PID_MOTOR_SCALE     -1
#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)
#define PID_INTEGRAL_LIMIT  50
#define PI 3.1415

//controller
#define U5    		vexRT[Btn5U]//5U
#define D5	  		vexRT[Btn5D]//5D
#define U6  			vexRT[Btn6U]//6U
#define D6	  		vexRT[Btn6D]//6D
#define U7  			vexRT[Btn7U]//7U
#define D7	  		vexRT[Btn7D]//7D
#define L7    		vexRT[Btn7L]//7L
#define R7				vexRT[Btn7R]//7R
#define U8  			vexRT[Btn8U]//8U
#define D8	  		vexRT[Btn8D]//8D
#define L8    		vexRT[Btn8L]//8L
#define R8	  		vexRT[Btn8R]//8R
//partner controller
#define U5_2    	vexRT[Btn5UXmtr2]//5U2
#define D5_2	    vexRT[Btn5DXmtr2]//5D2
#define U6_2			vexRT[Btn6UXmtr2]//6U2
#define D6_2	    vexRT[Btn6DXmtr2]//622
#define U7_2  		vexRT[Btn7UXmtr2]//7U2
#define D7_2	    vexRT[Btn7DXmtr2]//7D2
#define L7_2    	vexRT[Btn7LXmtr2]//7L2
#define R7_2	    vexRT[Btn7RXmtr2]//7R2
#define U8_2  		vexRT[Btn8UXmtr2]//8U2
#define D8_2	    vexRT[Btn8DXmtr2]//8D2
#define L8_2    	vexRT[Btn8LXmtr2]//8L2
#define R8_2	    vexRT[Btn8RXmtr2]//8R2
float circum = 4 * PI;//4 inch wheels
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
struct PIDPar {
	char sensor;
	volatile int forceDirection;//changing with multiple threads
	int motor1, motor2, thresh;
	float kP, kI, kD;
	bool reversed, Mopposite;
	volatile bool isRunning;
	float Integral, Derivative, LastError;
};
void resetPIDVals(const struct PIDPar* pid);
struct liftMech {
	int motors[2];
	char sensor;
	int max, min;
	PIDPar PID;
	volatile int goal;
	float velocity;
	int liftPIDelay, past;
};
struct liftMech mainLift;
struct liftMech FourBar;
struct liftMech MoGo;
struct position {
	float X, Y, angle;//current
	float goalX, goalY, goalAngle;//desired
}
struct position pos;
//other
bool rightSide = true;//false for red, going right, else true for blue, going left
volatile float velocity;
volatile float mRot;//current rotation
volatile float encoderAvg;//used only for straight fwds and bkwds direction
//AUTON SEQUENCE VARIABLES
volatile bool isMatchLoad = false;
//MISC FUNCTIONS
int getSign(int check) {
	if (check < 0) return -1;
	else if (check > 0) return 1;
	return 0;
}
float limitTo(float max, float val) {
	if (abs(val) < abs(max)) return val;
	else return getSign(val) * max;
}
//gets last average potentiometer vals
task potAverage() {
	//POT averages
#define SAMPLE_SIZE 4
#define NUMSLOTS 4 // second slots
	int gFourBarPotSamples[SAMPLE_SIZE]; // number of samples keep at 2^x
	int gChainMA_Sum;
	int ind_c;
	int gChainMA;
	//initializing pot avgs
	for (int ind = 0; ind<SAMPLE_SIZE; ind++) {
		gFourBarPotSamples[ind] = 0;
	}
	ind_c = 0;
	gChainMA_Sum = 0;
	gChainMA = 0;
	for (;;) {
		// enter the routine with ind_c pointing to the val to be replace, ie oldest
		int oldest_val;
		oldest_val = gFourBarPotSamples[ind_c]; // save the oldest samples
		gChainMA_Sum -= oldest_val;
		gFourBarPotSamples[ind_c] = 10 * ((int)((float)SensorValue[FourBarPot] / 10)); // update with the latest sample (also rounded off)
		gChainMA_Sum += gFourBarPotSamples[ind_c];
		ind_c = (ind_c + 1) % SAMPLE_SIZE; // this is a circular buffer, update index
		gChainMA = gChainMA_Sum >> 2; // divide by 4
		delay(10);
		//abortTimeslice();
	}
}
void resetPIDVals(const struct PIDPar* pid) {
	pid->LastError = 0;
	pid->Integral = 0;
	pid->Derivative = 0;
}
void pre_auton() {//dont care
	bStopTasksBetweenModes = true;
}
void initLiftType(liftMech lift, char sensor, int m1, int m2, int max, int min, int delayAmnt) {
	lift.sensor = sensor;
	lift.motors[0] = m1;
	lift.motors[1] = m2;
	lift.max = max;
	lift.min = min;
	lift.liftPIDelay = delayAmnt;
	lift.velocity = 0.0;
	lift.past = 0;
}
void initPID(PIDPar PIDType, char sensor, int thresh, float kP, float kI, float kD, int lastError, int Integral, bool reversed, bool isRunning) {
	PIDType.sensor = sensor;
	PIDType.thresh = thresh;
	PIDType.kP = kP;//0.2 //pretty efficient lift tho 0.075
	PIDType.kI = kI;// 0 .05;//0.04;
	PIDType.kD = kD;//1;
	PIDType.LastError = lastError;
	PIDType.Integral = Integral;
	PIDType.reversed = reversed;
	PIDType.isRunning = isRunning;
}
void clearEncoders() {
	SensorValue[LeftEncoder] = 0;
	SensorValue[RightEncoder] = 0;
}
void resetGyros() {
	SensorType[in1] = sensorNone;
	SensorType[in1] = sensorGyro;//resets gyro sensor, rly sketchy
	SensorValue[LeftGyro] = 0;//resets gyro sensor
	SensorType[in2] = sensorNone;
	SensorType[in2] = sensorGyro;//resets gyro sensor, rly sketchy
	SensorValue[RightGyro] = 0;//resets gyro sensor
	delay(300);
}
void initializeOpControl() {
	SensorValue[EvenLED] = 0;
	SensorValue[OddLED] = 0;
	clearLCDLine(0);
	clearLCDLine(1);
	resetGyros();
	clearEncoders();
	velocity = 0.0;
	////initializing lifts
	initLiftType(//MAIN LIFT
	mainLift,//for MAIN DR4B
	LiftPot,
	LiftTop,
	LiftBott,
	4050, //lift max
	2100, //lift min
	20); //pid delay
	mainLift.goal = SensorValue[mainLift.sensor];
	initPID(mainLift.PID, mainLift.sensor, 70, 0.35, 0.0, 0.0, 0, 0, true, true);//threshold CAN be much lower, like 30
	initLiftType(//FOURBAR
	FourBar,//for MoGo
	FourBarPot,
	R4Bar,
	L4Bar,
	2600, //lift max
	900, //lift min
	20); //pid delay
	FourBar.goal = SensorValue[FourBar.sensor];
	initPID(FourBar.PID, FourBar.sensor, 60, 0.4, 0.0, 0.0, 0, 0, true, true);
	initLiftType(//MOGO LIFT
	MoGo,//for Four Bar
	MoGoPot,
	RMogo,
	LMogo,
	4050, //lift max
	2000, //lift min
	20); //pid delay
	MoGo.goal = SensorValue[MoGo.sensor];
	initPID(MoGo.PID, MoGo.sensor, 30, 0.15, 0, 0, 0, 0, false, true);
}
float TruSpeed(float value) {//for all other polynomials; visit: goo.gl/mhvbx4
	return(getSign(value) * (value*value) / (127));
}//function for calculating the truSpeed function based off a polynomial
void liftMove(const struct liftMech* lift, int speed) {
	motor[lift->motors[0]] = speed;//up is fast
	motor[lift->motors[1]] = -speed;//up is fast
}
void drive() {
	//scale for joystick
	float partner = 0.6;
	float primary = 1;
	motor[RBaseFront] = primary*TruSpeed(vexRT[Ch2] + partner*vexRT[Ch2Xmtr2]);//trusped taking both controllers
	motor[RBaseBack] = motor[RBaseFront];//base motres go the same
	motor[LBaseFront] = primary*TruSpeed(vexRT[Ch3] + partner*vexRT[Ch3Xmtr2]);
	motor[LBaseBack] = motor[LBaseFront];
}
//function for driving the robot
float pidController(PIDPar PIDtype, int goal) {
	float error = SensorValue[PIDtype.sensor] - goal;//calculate error
	if (abs(error) < PIDtype.thresh) error = 0;
	float untilIntegral = 100;//considered "low threshold" for potentiometers
	if (PIDtype.kI != 0) {//calculates integral (only at very end)
		if (abs(error) < untilIntegral) PIDtype.Integral += error;//used for averaging the integral amount, later in motor power divided by 25
		else PIDtype.Integral = 0;
	}
	else PIDtype.Integral = 0;
	// calculate the derivative
	PIDtype.Derivative = error - PIDtype.LastError;//change in errors
	PIDtype.LastError = error;
	// calculate drive (in this case, just for the robot)
	int dir = 1;
	if (PIDtype.reversed) dir = -1;
	return(dir * getSign(error) * abs((PIDtype.kP * error) + (PIDtype.kI * PIDtype.Integral) + (PIDtype.kD * PIDtype.Derivative)));
}
void PIDLift(const struct liftMech* lift) {
	if (lift->PID.isRunning) {
		int power = pidController(lift->PID, lift->goal);
		liftMove(lift, power);
	}
	else {
		resetPIDVals(lift->PID);
	}
	delay(lift->liftPIDelay);
}
task SpeakMe() {//speaker
	/*for(;;){
	if(abs(vexRT[Ch2]) > 20 && abs(vexRT[Ch3]) > 20 && U5 && D5 ) {
	playSoundFile("xteem.wav");
	delay(500);
	playSoundFile("");
	}
	else playSoundFile("");
	delay(50);
	}*/
}
//////////////////////////////////////////
//////////////////////////////////////////
/////////////BASIC FUNCTIONS//////////////
//////////////////////////////////////////
//////////////////////////////////////////
void driveLR(int right, int left) {
	motor[RBaseBack] = right;
	motor[RBaseFront] = right;
	motor[LBaseFront] = left;
	motor[LBaseBack] = left;
}
void fwds(int power, int angle) {//drive base forwards
	int speed = limitTo(127, power);//SO GOOD
	int dirSkew = (SensorValue[RightGyro] - angle);
	driveLR(limitTo(127, speed - dirSkew), limitTo(127, speed + dirSkew));
}
void rot(float speed) {//rotates base
	motor[RBaseBack] = speed;
	motor[RBaseFront] = speed;
	motor[LBaseFront] = -speed;
	motor[LBaseBack] = -speed;
}
void driveFor(float goal) {//drives for certain inches
	//works best from 1 to 40 ish.
	SensorValue[LeftEncoder] = 0;
	SensorValue[RightEncoder] = 0;
	goal *= 2;//doubles "goal" not tuned very well as of rn
	int thresh = 2;//10 ticks
	int initDir = mRot;
	//ClearTimer(T1);
	float dP = 20;//multiplier for velocity controller
	float vel = abs(velocity);
	while (abs(goal * circum - encoderAvg) > thresh) {
		fwds(dP * ((goal*circum - encoderAvg - 0.1*vel)), initDir);
	}
	return;
}
void rotFor(float rotGoal) {//rotates for certain degrees
	int rotScale = 10;//gyro is from -3600 to 3600
	int thresh = 4 * rotScale;//4 degrees
	rotGoal = getSign(rotGoal)*(abs(rotGoal) + 5);
	rotGoal *= rotScale;//scales to degrees
	int initial = mRot;
	float dP = 5;//multiplier for velocity controller
	int current = 0;//to not have to
	while (abs(current - rotGoal) > thresh) {
		current = abs(mRot - initial);
		rot(dP * ((rotGoal - abs(mRot - initial) - (velocity * 3)) * (10)));//SO GOOD
	}
	return;
}
//////////////////////////////////////////
//////////////////////////////////////////
///////////ADVANCED FUNCTIONS/////////////
//////////////////////////////////////////
//////////////////////////////////////////
void manualLiftControl(liftMech lift, int bUp, int bDown, int bUp2, int bDown2, bool reversed, int maxSpeed) {
	int dir = 1;
	if (reversed) dir = -1;
	bool upButton = (bUp == 1 || bUp2 == 1);//defining what is up button
	bool downButton = (bDown == 1 || bDown2 == 1);//defining what is down button
	if (!upButton && !downButton) liftMove(lift, 0);//not pressed any buttons
	else if ((SensorValue[lift.sensor] >= lift.max && (upButton))
		|| (SensorValue[lift.sensor] <= lift.min && (downButton)))//pressing buttons but surpassed limits
	liftMove(lift, 0);//power 0
	else if (upButton) liftMove(lift, dir * maxSpeed);//up max speed
	else if (downButton) liftMove(lift, dir * -maxSpeed);//down max speed
	else liftMove(lift, 0);
}
float calcLiftVel(liftMech lift, float dist, float delayAmount) {
	return ((SensorValue(lift.sensor) - lift.past) / dist) / ((float)(delayAmount / 1000));//1000 ms in 1s;
}
task MeasureSpeed() {
	/*MEASURING IN IN/SEC*/
	int encoderPast = 0;
	float dist = 1.125*PI;
	float delayAmount = 50;
	for (;;) {
		//base velocity
		velocity = ((SensorValue(LeftEncoder) - encoderPast) / circum) / (delayAmount / 1000);//1000 ms in 1s
		encoderPast = SensorValue(LeftEncoder);
		//lift velocities
		mainLift.velocity = calcLiftVel(mainLift, dist, delayAmount);
		mainLift.past = SensorValue(mainLift.sensor);
		FourBar.velocity = calcLiftVel(FourBar, dist, delayAmount);
		FourBar.past = SensorValue(FourBar.sensor);
		MoGo.velocity = calcLiftVel(MoGo, dist, delayAmount);
		MoGo.past = SensorValue(MoGo.sensor);
		//does the waitings
		delay(delayAmount);
	}
}//task for measuring velocity of the base, in IN/Sec
void LiftLift(const struct liftMech* lift, int bUp, int bDown, int bUp2, int bDown2, float velLimit) {
	if (bUp || bDown || bUp2 || bDown2) {
		lift->PID.isRunning = false;
		manualLiftControl(*lift, bUp, bDown, bUp2, bDown2, false, 127);
	}
	else {
		if (abs(SensorValue[lift->sensor] - lift->goal) < 200 || abs(lift->velocity) < 90) {
			if (!lift->PID.isRunning) {
				lift->goal = SensorValue[lift->sensor];
			}
			lift->PID.isRunning = true;
		}
		else {
			lift->PID.isRunning = false;
			liftMove(lift, 0);
		}
		//liftMove(MoGo, 0);
	}
}
void UpUntil(liftMech lift, int goal, int speed) {
	lift.PID.isRunning = false;
	while (SensorValue[lift.sensor] < goal) {//brings lift down to goal
		liftMove(lift, speed);
		//killswitch?
	}
	lift.goal = SensorValue[lift.sensor];//keeps lift in last position
	lift.PID.isRunning = true;
	return;
}
void DownUntil(liftMech lift, int goal, int speed) {
	lift.PID.isRunning = false;
	while (SensorValue[lift.sensor] > goal) {//brings lift down to goal
		liftMove(lift, -speed);
		//killswitch?
	}
	lift.goal = SensorValue[lift.sensor];//keeps lift in last position
	lift.PID.isRunning = true;
	return;
}
task LiftControlTask() {
	for (;;) {//while true
		LiftLift(mainLift, U6, D6, 0, 0, 40);
		PIDLift(mainLift);
		LiftLift(FourBar, U5, D5, U5_2, D5_2, 950);
		PIDLift(FourBar);
		LiftLift(MoGo, D8, U8, D8_2, U8_2, 90);
		PIDLift(MoGo);
		delay(10);
	}
}
task sensorsUpdate() {
	for (;;) {
		mRot = SensorValue[RightGyro];//0.5*(SensorValue[RightGyro] + SensorValue[LeftGyro]);
		encoderAvg = 0.5*(SensorValue[RightEncoder] + SensorValue[LeftEncoder]);
		delay(1);
	}
}
task currentPos() {
	for (;;) {
		pos.X = 0;//do fancy trig
		pos.Y = 0;//do fancy trig
		pos.angle = mRot;
		delay(5);
	}
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
task autonomous() {
	//go die
}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
int currentCone = 0;
task autoStack() {
	for (;;) {
		if (U7 && currentCone < 12) {
			mainLift.PID.isRunning = false;
			FourBar.PID.isRunning = false;
			int coneHeight = 150;//where to go
			int delayAmnt = 0;
			int initialHeight;//how much to go up and down once reached coneHeight's height
			if (currentCone == 0) {
				initialHeight = 400;
			}
			if (currentCone == 1) {
				initialHeight = 300;
				coneHeight = 160;
			}
			if (currentCone == 2) {
				initialHeight = 300;
			}
			if (currentCone == 3) {
				initialHeight = 350;
				coneHeight = 130;
			}
			if (currentCone == 4) {
				initialHeight = 370;
			}
			if (currentCone == 5) {
				initialHeight = 340;
				coneHeight = 130;
			}
			if (currentCone == 6) {
				initialHeight = 380;
			}
			//starts getting janky here
			if (currentCone == 7) {
				delayAmnt = 150;
				coneHeight = 130;
				initialHeight = 480;
			}
			if (currentCone == 8) {
				delayAmnt = 150;
				coneHeight = 150;
				initialHeight = 450;
			}
			if (currentCone == 9) {
				coneHeight = 170;
				delayAmnt = 240;
				initialHeight = 400;
			}
			if (currentCone == 10) {
				delayAmnt = 200;
				initialHeight = 420;
				coneHeight = 200;//basically bring to maximum (because limiter below)
			}
			UpUntil(mainLift, limitTo(mainLift.max, currentCone*coneHeight + mainLift.min + initialHeight), 127);
			//bring fourbar up
			delay(delayAmnt / 2);
			UpUntil(FourBar, FourBar.max, 127);
			//keep fourbar up
			FourBar.goal = FourBar.max;
			FourBar.PID.isRunning = true;
			delay(delayAmnt*0.75);
			//bring lift down
			DownUntil(mainLift, currentCone*coneHeight + mainLift.min, 127);
			//bring fourbar down
			FourBar.PID.isRunning = false;
			DownUntil(FourBar, FourBar.min, 127);
			//FourBar.goal = FourBar.min;
			currentCone++;//assumes got cone
		}
	}
}
void superMoGo() {
	///bring 4bar down
	FourBar.PID.isRunning = false;
	liftMove(FourBar, -40);
	//do this WHILE bringing mogo OUT
	UpUntil(MoGo, MoGo.max, 127);
	delay(300);
	UpUntil(mainLift, limitTo(mainLift.max, SensorValue[mainLift.sensor] + 150), 127);//goes up a little bit (no more than maximum)
	UpUntil(FourBar, FourBar.max, 127);//brings up four bar to let go
	driveFor(-5);//goes back a lil
}
task usercontrol() {//initializes everything
	initializeOpControl();
	startTask(potAverage);
	startTask(LiftControlTask);//individual pid for lift type
	startTask(MeasureSpeed);//velocity measurer for base
	startTask(sensorsUpdate);
	startTask(autoStack);
	displayLCDCenteredString(0, "5327Champs");

	for (;;) {
		if (D7) currentCone = 0;//reset
			if (L8) superMoGo();
		if (R7) driveFor(70);
		if (L7) rotFor(90);
		drive();
		delay(15);//~60hz
	}
}//function for operator control
