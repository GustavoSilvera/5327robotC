#pragma config(Motor,  port1,           baseRight,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           baseLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           baseMiddle,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#pragma debuggerWindows(debugStream)

#define MAX_NUM_MOTRES 6                // Maximum number of motors on any single mechanism

// Individual list nodes struct
struct motorNode{
	motorNode *next;		                // neighbouring node
	char name;
	bool reversed;
	int identification;
} motorNode;

// List struct to hold the nodes
struct motorList{
	motorNode *head;                   // pointer to the node at the head of the list
	motorNode *tail;                   // pointer to the node at the top of the list
	int size;                             // current size of the list
} motorList;

struct motorList motorListPool[MAX_NUM_MOTRES]; // array of nodes
bool allocStatus[MAX_NUM_MOTRES];       // Array to keep track of allocation
// status of nodes. true == node is allocated

motorNode * newAlloc();
void FREE(motorNode *motorID);
void initList(motorList *list);

motorNode * newAlloc(){
	for (int i = 0; i < MAX_NUM_MOTRES; i++){
		// Return the node if it is not already allocated
		if (!allocStatus[i]){
			writeDebugStreamLine("NEW: found node spot [%d]: %p", i, motorListPool[i]);
			allocStatus[i] = true;//claims that node is already allocated
			return motorListPool[i];
		}
	}
	// No free nodes available
	writeDebugStreamLine("NEW: no free nodes left");
	return NULL;
}

void FREE(motorNode *motorID){//like deleting nodes
	for (int i = 0; i < MAX_NUM_MOTRES; i++){
		if (allocStatus[i]){
			if (motorID == motorListPool[i]){//if indeed allocated and exists
				writeDebugStreamLine("FREE: deleting node[%d]: %p", i, motorListPool[i]);
				allocStatus[i] = false;
				memset(motorID, 0, sizeof(motorNode));
				return;
			}
		}
	}
	writeDebugStreamLine("FREE: could not find node: %p", motorID);
}

void insertNode(motorList *list, motorNode *motorID, motorNode *newMotorID){
	writeDebugStreamLine("Inserting new node %p after node %p in list %p", motorID, newMotorID, list);
	// Is the list empty?
	if (list->size == 0){
		list->head = newMotorID;
		list->tail = newMotorID;
	}
	// node == NULL, so put the newNode at the start
	// of the list
	else if (motorID == NULL){
		newMotorID->next = list->head;
		list->head = newMotorID;//placed at start of list
	}
	// Insert the newNode (newMotorID) into the list, after the old node (motorID)
	else {
		newMotorID->next = motorID->next;//places between motorID and the next motorID
		motorID->next = newMotorID;
		// if the node was the tail, update this pointer to the newNode
		if (list->tail == motorID) list->tail = newMotorID;
	}
	list->size++;
}

void deleteNode(motorList *list, motorNode *motorIDtoDie){//deletes node
	writeDebugStreamLine("Deleting node %p from list %p", list, motorIDtoDie);
	struct motorNode *neighbour;
	// We only have one node!
	if (list->size == 1) {//sets list to empty
		list->head = NULL;
		list->tail = NULL;
		list->size = 0;//empty list
		FREE(motorIDtoDie);//deallocates the memory location
	}
	// The node we want to delete is the head of the list
	else if (list->head == motorIDtoDie){
		list->head = motorIDtoDie->next;//sets the next motor to the first
		list->size--;
		FREE(motorIDtoDie);//deallocates its memory location
	}
	else {
		// we need to start looking for the obsoleteNode's
		// left neighbour
		neighbour = list->head;
		while (neighbour != NULL) {
			// The neighbour's neighbour is the node we're looking for
			if (neighbour->next == motorIDtoDie){
				// Check if it is also the tail
				if(motorIDtoDie == list->tail){
					list->tail = neighbour;
				}
				// Update the neighbour's left neighbour
				neighbour->next = motorIDtoDie->next;
				list->size--;
				FREE(motorIDtoDie);
				return;
			}
			// advance to the next node
			neighbour = neighbour->next;
		}
	}
}

void initList(motorList *list){
	writeDebugStreamLine("Initialising the list %p", list);
	// Reset all the value to 0
	memset(motorListPool, 0, sizeof(motorNode) * MAX_NUM_MOTRES);//allocates amount of memory for max #motres
	memset(allocStatus, false, sizeof(bool) * MAX_NUM_MOTRES);
	// Set the current head and tail to the first node
	list->head = NULL;
	list->tail = NULL;
	// Set the size to 0
	list->size = 0;
}

void appendNode(motorList *list, motorNode *newMotorID){
	writeDebugStreamLine("appended: %p", newMotorID);
	insertNode(list, list->tail, newMotorID);
}
void printList(motorList *list){
	// set the initial node to the list's head node
	struct motorNode *motorID = list->head;
	writeDebugStream("motorList: size: %d, items: ", list->size);
	// don't bother to print the list if it's empty
	if (list->size == 0){
		writeDebugStreamLine("motorList: list empty");
		return;
	}
	// print nodes until we reach the end
	for(int i = 0; i < list->size; i++) {
		if(allocStatus[i] == true){
			writeDebugStream("%c ", motorID->name);
			// go to the next node
			motorID = motorID->next;
		}
	}
	writeDebugStreamLine(" ");
}
task main ()
{
	clearDebugStream();
	initList(motorListPool);

	const int maxInThisCase = 5;
	struct motorNode *newMotorPtr;
	// Fill our list
	for (int i = 0; i < maxInThisCase; ++i) {
		newMotorPtr = newAlloc();
		newMotorPtr->identification = i;
		appendNode(motorListPool, newMotorPtr);
	}

	struct motorNode *motorIterator = motorListPool.head;
	motorIterator->name = 'a';//baseRight;
	motorIterator = motorIterator->next;
	motorIterator->name = 'b';//baseLeft;
	motorIterator = motorIterator->next;
	motorIterator->name = 'c';//baseMiddle;
	motorIterator = motorIterator->next;
	motorIterator->name = 'd';//baseMiddle;
	motorIterator = motorIterator->next;
	motorIterator->name = 'e';//baseMiddle;

	printList(motorListPool);
}
